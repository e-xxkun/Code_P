// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flexran.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flexran_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flexran_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "stats_messages.pb.h"
#include "header.pb.h"
#include "time_common.pb.h"
#include "config_messages.pb.h"
#include "controller_commands.pb.h"
#include "config_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flexran_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flexran_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flexran_2eproto;
namespace protocol {
class flex_agent_reconfiguration;
class flex_agent_reconfigurationDefaultTypeInternal;
extern flex_agent_reconfigurationDefaultTypeInternal _flex_agent_reconfiguration_default_instance_;
class flex_control_delegation;
class flex_control_delegationDefaultTypeInternal;
extern flex_control_delegationDefaultTypeInternal _flex_control_delegation_default_instance_;
class flex_disconnect;
class flex_disconnectDefaultTypeInternal;
extern flex_disconnectDefaultTypeInternal _flex_disconnect_default_instance_;
class flex_dl_mac_config;
class flex_dl_mac_configDefaultTypeInternal;
extern flex_dl_mac_configDefaultTypeInternal _flex_dl_mac_config_default_instance_;
class flex_echo_reply;
class flex_echo_replyDefaultTypeInternal;
extern flex_echo_replyDefaultTypeInternal _flex_echo_reply_default_instance_;
class flex_echo_reply_latency;
class flex_echo_reply_latencyDefaultTypeInternal;
extern flex_echo_reply_latencyDefaultTypeInternal _flex_echo_reply_latency_default_instance_;
class flex_echo_request;
class flex_echo_requestDefaultTypeInternal;
extern flex_echo_requestDefaultTypeInternal _flex_echo_request_default_instance_;
class flex_echo_request_latency;
class flex_echo_request_latencyDefaultTypeInternal;
extern flex_echo_request_latencyDefaultTypeInternal _flex_echo_request_latency_default_instance_;
class flex_enb_config_reply;
class flex_enb_config_replyDefaultTypeInternal;
extern flex_enb_config_replyDefaultTypeInternal _flex_enb_config_reply_default_instance_;
class flex_enb_config_request;
class flex_enb_config_requestDefaultTypeInternal;
extern flex_enb_config_requestDefaultTypeInternal _flex_enb_config_request_default_instance_;
class flex_hello;
class flex_helloDefaultTypeInternal;
extern flex_helloDefaultTypeInternal _flex_hello_default_instance_;
class flex_ho_command;
class flex_ho_commandDefaultTypeInternal;
extern flex_ho_commandDefaultTypeInternal _flex_ho_command_default_instance_;
class flex_lc_config_reply;
class flex_lc_config_replyDefaultTypeInternal;
extern flex_lc_config_replyDefaultTypeInternal _flex_lc_config_reply_default_instance_;
class flex_lc_config_request;
class flex_lc_config_requestDefaultTypeInternal;
extern flex_lc_config_requestDefaultTypeInternal _flex_lc_config_request_default_instance_;
class flex_rrc_triggering;
class flex_rrc_triggeringDefaultTypeInternal;
extern flex_rrc_triggeringDefaultTypeInternal _flex_rrc_triggering_default_instance_;
class flex_sf_trigger;
class flex_sf_triggerDefaultTypeInternal;
extern flex_sf_triggerDefaultTypeInternal _flex_sf_trigger_default_instance_;
class flex_stats_reply;
class flex_stats_replyDefaultTypeInternal;
extern flex_stats_replyDefaultTypeInternal _flex_stats_reply_default_instance_;
class flex_stats_request;
class flex_stats_requestDefaultTypeInternal;
extern flex_stats_requestDefaultTypeInternal _flex_stats_request_default_instance_;
class flex_ue_config_reply;
class flex_ue_config_replyDefaultTypeInternal;
extern flex_ue_config_replyDefaultTypeInternal _flex_ue_config_reply_default_instance_;
class flex_ue_config_request;
class flex_ue_config_requestDefaultTypeInternal;
extern flex_ue_config_requestDefaultTypeInternal _flex_ue_config_request_default_instance_;
class flex_ue_state_change;
class flex_ue_state_changeDefaultTypeInternal;
extern flex_ue_state_changeDefaultTypeInternal _flex_ue_state_change_default_instance_;
class flex_ul_mac_config;
class flex_ul_mac_configDefaultTypeInternal;
extern flex_ul_mac_configDefaultTypeInternal _flex_ul_mac_config_default_instance_;
class flex_ul_sr_info;
class flex_ul_sr_infoDefaultTypeInternal;
extern flex_ul_sr_infoDefaultTypeInternal _flex_ul_sr_info_default_instance_;
class flexran_message;
class flexran_messageDefaultTypeInternal;
extern flexran_messageDefaultTypeInternal _flexran_message_default_instance_;
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::protocol::flex_agent_reconfiguration* Arena::CreateMaybeMessage<::protocol::flex_agent_reconfiguration>(Arena*);
template<> ::protocol::flex_control_delegation* Arena::CreateMaybeMessage<::protocol::flex_control_delegation>(Arena*);
template<> ::protocol::flex_disconnect* Arena::CreateMaybeMessage<::protocol::flex_disconnect>(Arena*);
template<> ::protocol::flex_dl_mac_config* Arena::CreateMaybeMessage<::protocol::flex_dl_mac_config>(Arena*);
template<> ::protocol::flex_echo_reply* Arena::CreateMaybeMessage<::protocol::flex_echo_reply>(Arena*);
template<> ::protocol::flex_echo_reply_latency* Arena::CreateMaybeMessage<::protocol::flex_echo_reply_latency>(Arena*);
template<> ::protocol::flex_echo_request* Arena::CreateMaybeMessage<::protocol::flex_echo_request>(Arena*);
template<> ::protocol::flex_echo_request_latency* Arena::CreateMaybeMessage<::protocol::flex_echo_request_latency>(Arena*);
template<> ::protocol::flex_enb_config_reply* Arena::CreateMaybeMessage<::protocol::flex_enb_config_reply>(Arena*);
template<> ::protocol::flex_enb_config_request* Arena::CreateMaybeMessage<::protocol::flex_enb_config_request>(Arena*);
template<> ::protocol::flex_hello* Arena::CreateMaybeMessage<::protocol::flex_hello>(Arena*);
template<> ::protocol::flex_ho_command* Arena::CreateMaybeMessage<::protocol::flex_ho_command>(Arena*);
template<> ::protocol::flex_lc_config_reply* Arena::CreateMaybeMessage<::protocol::flex_lc_config_reply>(Arena*);
template<> ::protocol::flex_lc_config_request* Arena::CreateMaybeMessage<::protocol::flex_lc_config_request>(Arena*);
template<> ::protocol::flex_rrc_triggering* Arena::CreateMaybeMessage<::protocol::flex_rrc_triggering>(Arena*);
template<> ::protocol::flex_sf_trigger* Arena::CreateMaybeMessage<::protocol::flex_sf_trigger>(Arena*);
template<> ::protocol::flex_stats_reply* Arena::CreateMaybeMessage<::protocol::flex_stats_reply>(Arena*);
template<> ::protocol::flex_stats_request* Arena::CreateMaybeMessage<::protocol::flex_stats_request>(Arena*);
template<> ::protocol::flex_ue_config_reply* Arena::CreateMaybeMessage<::protocol::flex_ue_config_reply>(Arena*);
template<> ::protocol::flex_ue_config_request* Arena::CreateMaybeMessage<::protocol::flex_ue_config_request>(Arena*);
template<> ::protocol::flex_ue_state_change* Arena::CreateMaybeMessage<::protocol::flex_ue_state_change>(Arena*);
template<> ::protocol::flex_ul_mac_config* Arena::CreateMaybeMessage<::protocol::flex_ul_mac_config>(Arena*);
template<> ::protocol::flex_ul_sr_info* Arena::CreateMaybeMessage<::protocol::flex_ul_sr_info>(Arena*);
template<> ::protocol::flexran_message* Arena::CreateMaybeMessage<::protocol::flexran_message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {

enum flexran_direction : int {
  NOT_SET = 0,
  INITIATING_MESSAGE = 1,
  SUCCESSFUL_OUTCOME = 2,
  UNSUCCESSFUL_OUTCOME = 3
};
bool flexran_direction_IsValid(int value);
constexpr flexran_direction flexran_direction_MIN = NOT_SET;
constexpr flexran_direction flexran_direction_MAX = UNSUCCESSFUL_OUTCOME;
constexpr int flexran_direction_ARRAYSIZE = flexran_direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* flexran_direction_descriptor();
template<typename T>
inline const std::string& flexran_direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, flexran_direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function flexran_direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    flexran_direction_descriptor(), enum_t_value);
}
inline bool flexran_direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, flexran_direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<flexran_direction>(
    flexran_direction_descriptor(), name, value);
}
enum flexran_err : int {
  NO_ERR = 0,
  MSG_DEQUEUING = -1,
  MSG_ENQUEUING = -2,
  MSG_DECODING = -3,
  MSG_ENCODING = -4,
  MSG_BUILD = -5,
  MSG_NOT_SUPPORTED = -6,
  MSG_NOT_HANDLED = -7,
  MSG_NOT_VALIDATED = -8,
  MSG_OUT_DATED = -9,
  UNEXPECTED = -100
};
bool flexran_err_IsValid(int value);
constexpr flexran_err flexran_err_MIN = UNEXPECTED;
constexpr flexran_err flexran_err_MAX = NO_ERR;
constexpr int flexran_err_ARRAYSIZE = flexran_err_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* flexran_err_descriptor();
template<typename T>
inline const std::string& flexran_err_Name(T enum_t_value) {
  static_assert(::std::is_same<T, flexran_err>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function flexran_err_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    flexran_err_descriptor(), enum_t_value);
}
inline bool flexran_err_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, flexran_err* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<flexran_err>(
    flexran_err_descriptor(), name, value);
}
enum flex_bs_capability : int {
  LOPHY = 0,
  HIPHY = 1,
  LOMAC = 2,
  HIMAC = 3,
  RLC = 4,
  PDCP = 5,
  SDAP = 6,
  RRC = 7,
  S1AP = 8
};
bool flex_bs_capability_IsValid(int value);
constexpr flex_bs_capability flex_bs_capability_MIN = LOPHY;
constexpr flex_bs_capability flex_bs_capability_MAX = S1AP;
constexpr int flex_bs_capability_ARRAYSIZE = flex_bs_capability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* flex_bs_capability_descriptor();
template<typename T>
inline const std::string& flex_bs_capability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, flex_bs_capability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function flex_bs_capability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    flex_bs_capability_descriptor(), enum_t_value);
}
inline bool flex_bs_capability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, flex_bs_capability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<flex_bs_capability>(
    flex_bs_capability_descriptor(), name, value);
}
enum flex_bs_split : int {
  F1 = 0,
  nFAPI = 1,
  IF4 = 2,
  IF4p5 = 3,
  IF5 = 4
};
bool flex_bs_split_IsValid(int value);
constexpr flex_bs_split flex_bs_split_MIN = F1;
constexpr flex_bs_split flex_bs_split_MAX = IF5;
constexpr int flex_bs_split_ARRAYSIZE = flex_bs_split_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* flex_bs_split_descriptor();
template<typename T>
inline const std::string& flex_bs_split_Name(T enum_t_value) {
  static_assert(::std::is_same<T, flex_bs_split>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function flex_bs_split_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    flex_bs_split_descriptor(), enum_t_value);
}
inline bool flex_bs_split_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, flex_bs_split* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<flex_bs_split>(
    flex_bs_split_descriptor(), name, value);
}
// ===================================================================

class flexran_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flexran_message) */ {
 public:
  inline flexran_message() : flexran_message(nullptr) {}
  virtual ~flexran_message();

  flexran_message(const flexran_message& from);
  flexran_message(flexran_message&& from) noexcept
    : flexran_message() {
    *this = ::std::move(from);
  }

  inline flexran_message& operator=(const flexran_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline flexran_message& operator=(flexran_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flexran_message& default_instance();

  enum MsgCase {
    kHelloMsg = 1,
    kEchoRequestMsg = 2,
    kEchoReplyMsg = 3,
    kStatsRequestMsg = 4,
    kStatsReplyMsg = 5,
    kSfTriggerMsg = 6,
    kUlSrInfoMsg = 7,
    kEnbConfigRequestMsg = 8,
    kEnbConfigReplyMsg = 9,
    kUeConfigRequestMsg = 10,
    kUeConfigReplyMsg = 11,
    kLcConfigRequestMsg = 12,
    kLcConfigReplyMsg = 13,
    kDlMacConfigMsg = 14,
    kUeStateChangeMsg = 15,
    kControlDelegationMsg = 16,
    kAgentReconfigurationMsg = 17,
    kRrcTriggering = 18,
    kUlMacConfigMsg = 19,
    kDisconnectMsg = 20,
    kHoCommand = 21,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flexran_message* internal_default_instance() {
    return reinterpret_cast<const flexran_message*>(
               &_flexran_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(flexran_message& a, flexran_message& b) {
    a.Swap(&b);
  }
  inline void Swap(flexran_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flexran_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flexran_message* New() const final {
    return CreateMaybeMessage<flexran_message>(nullptr);
  }

  flexran_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flexran_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flexran_message& from);
  void MergeFrom(const flexran_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flexran_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flexran_message";
  }
  protected:
  explicit flexran_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDirFieldNumber = 100,
    kHelloMsgFieldNumber = 1,
    kEchoRequestMsgFieldNumber = 2,
    kEchoReplyMsgFieldNumber = 3,
    kStatsRequestMsgFieldNumber = 4,
    kStatsReplyMsgFieldNumber = 5,
    kSfTriggerMsgFieldNumber = 6,
    kUlSrInfoMsgFieldNumber = 7,
    kEnbConfigRequestMsgFieldNumber = 8,
    kEnbConfigReplyMsgFieldNumber = 9,
    kUeConfigRequestMsgFieldNumber = 10,
    kUeConfigReplyMsgFieldNumber = 11,
    kLcConfigRequestMsgFieldNumber = 12,
    kLcConfigReplyMsgFieldNumber = 13,
    kDlMacConfigMsgFieldNumber = 14,
    kUeStateChangeMsgFieldNumber = 15,
    kControlDelegationMsgFieldNumber = 16,
    kAgentReconfigurationMsgFieldNumber = 17,
    kRrcTriggeringFieldNumber = 18,
    kUlMacConfigMsgFieldNumber = 19,
    kDisconnectMsgFieldNumber = 20,
    kHoCommandFieldNumber = 21,
  };
  // optional .protocol.flexran_direction msg_dir = 100;
  bool has_msg_dir() const;
  private:
  bool _internal_has_msg_dir() const;
  public:
  void clear_msg_dir();
  ::protocol::flexran_direction msg_dir() const;
  void set_msg_dir(::protocol::flexran_direction value);
  private:
  ::protocol::flexran_direction _internal_msg_dir() const;
  void _internal_set_msg_dir(::protocol::flexran_direction value);
  public:

  // .protocol.flex_hello hello_msg = 1;
  bool has_hello_msg() const;
  private:
  bool _internal_has_hello_msg() const;
  public:
  void clear_hello_msg();
  const ::protocol::flex_hello& hello_msg() const;
  ::protocol::flex_hello* release_hello_msg();
  ::protocol::flex_hello* mutable_hello_msg();
  void set_allocated_hello_msg(::protocol::flex_hello* hello_msg);
  private:
  const ::protocol::flex_hello& _internal_hello_msg() const;
  ::protocol::flex_hello* _internal_mutable_hello_msg();
  public:
  void unsafe_arena_set_allocated_hello_msg(
      ::protocol::flex_hello* hello_msg);
  ::protocol::flex_hello* unsafe_arena_release_hello_msg();

  // .protocol.flex_echo_request echo_request_msg = 2;
  bool has_echo_request_msg() const;
  private:
  bool _internal_has_echo_request_msg() const;
  public:
  void clear_echo_request_msg();
  const ::protocol::flex_echo_request& echo_request_msg() const;
  ::protocol::flex_echo_request* release_echo_request_msg();
  ::protocol::flex_echo_request* mutable_echo_request_msg();
  void set_allocated_echo_request_msg(::protocol::flex_echo_request* echo_request_msg);
  private:
  const ::protocol::flex_echo_request& _internal_echo_request_msg() const;
  ::protocol::flex_echo_request* _internal_mutable_echo_request_msg();
  public:
  void unsafe_arena_set_allocated_echo_request_msg(
      ::protocol::flex_echo_request* echo_request_msg);
  ::protocol::flex_echo_request* unsafe_arena_release_echo_request_msg();

  // .protocol.flex_echo_reply echo_reply_msg = 3;
  bool has_echo_reply_msg() const;
  private:
  bool _internal_has_echo_reply_msg() const;
  public:
  void clear_echo_reply_msg();
  const ::protocol::flex_echo_reply& echo_reply_msg() const;
  ::protocol::flex_echo_reply* release_echo_reply_msg();
  ::protocol::flex_echo_reply* mutable_echo_reply_msg();
  void set_allocated_echo_reply_msg(::protocol::flex_echo_reply* echo_reply_msg);
  private:
  const ::protocol::flex_echo_reply& _internal_echo_reply_msg() const;
  ::protocol::flex_echo_reply* _internal_mutable_echo_reply_msg();
  public:
  void unsafe_arena_set_allocated_echo_reply_msg(
      ::protocol::flex_echo_reply* echo_reply_msg);
  ::protocol::flex_echo_reply* unsafe_arena_release_echo_reply_msg();

  // .protocol.flex_stats_request stats_request_msg = 4;
  bool has_stats_request_msg() const;
  private:
  bool _internal_has_stats_request_msg() const;
  public:
  void clear_stats_request_msg();
  const ::protocol::flex_stats_request& stats_request_msg() const;
  ::protocol::flex_stats_request* release_stats_request_msg();
  ::protocol::flex_stats_request* mutable_stats_request_msg();
  void set_allocated_stats_request_msg(::protocol::flex_stats_request* stats_request_msg);
  private:
  const ::protocol::flex_stats_request& _internal_stats_request_msg() const;
  ::protocol::flex_stats_request* _internal_mutable_stats_request_msg();
  public:
  void unsafe_arena_set_allocated_stats_request_msg(
      ::protocol::flex_stats_request* stats_request_msg);
  ::protocol::flex_stats_request* unsafe_arena_release_stats_request_msg();

  // .protocol.flex_stats_reply stats_reply_msg = 5;
  bool has_stats_reply_msg() const;
  private:
  bool _internal_has_stats_reply_msg() const;
  public:
  void clear_stats_reply_msg();
  const ::protocol::flex_stats_reply& stats_reply_msg() const;
  ::protocol::flex_stats_reply* release_stats_reply_msg();
  ::protocol::flex_stats_reply* mutable_stats_reply_msg();
  void set_allocated_stats_reply_msg(::protocol::flex_stats_reply* stats_reply_msg);
  private:
  const ::protocol::flex_stats_reply& _internal_stats_reply_msg() const;
  ::protocol::flex_stats_reply* _internal_mutable_stats_reply_msg();
  public:
  void unsafe_arena_set_allocated_stats_reply_msg(
      ::protocol::flex_stats_reply* stats_reply_msg);
  ::protocol::flex_stats_reply* unsafe_arena_release_stats_reply_msg();

  // .protocol.flex_sf_trigger sf_trigger_msg = 6;
  bool has_sf_trigger_msg() const;
  private:
  bool _internal_has_sf_trigger_msg() const;
  public:
  void clear_sf_trigger_msg();
  const ::protocol::flex_sf_trigger& sf_trigger_msg() const;
  ::protocol::flex_sf_trigger* release_sf_trigger_msg();
  ::protocol::flex_sf_trigger* mutable_sf_trigger_msg();
  void set_allocated_sf_trigger_msg(::protocol::flex_sf_trigger* sf_trigger_msg);
  private:
  const ::protocol::flex_sf_trigger& _internal_sf_trigger_msg() const;
  ::protocol::flex_sf_trigger* _internal_mutable_sf_trigger_msg();
  public:
  void unsafe_arena_set_allocated_sf_trigger_msg(
      ::protocol::flex_sf_trigger* sf_trigger_msg);
  ::protocol::flex_sf_trigger* unsafe_arena_release_sf_trigger_msg();

  // .protocol.flex_ul_sr_info ul_sr_info_msg = 7;
  bool has_ul_sr_info_msg() const;
  private:
  bool _internal_has_ul_sr_info_msg() const;
  public:
  void clear_ul_sr_info_msg();
  const ::protocol::flex_ul_sr_info& ul_sr_info_msg() const;
  ::protocol::flex_ul_sr_info* release_ul_sr_info_msg();
  ::protocol::flex_ul_sr_info* mutable_ul_sr_info_msg();
  void set_allocated_ul_sr_info_msg(::protocol::flex_ul_sr_info* ul_sr_info_msg);
  private:
  const ::protocol::flex_ul_sr_info& _internal_ul_sr_info_msg() const;
  ::protocol::flex_ul_sr_info* _internal_mutable_ul_sr_info_msg();
  public:
  void unsafe_arena_set_allocated_ul_sr_info_msg(
      ::protocol::flex_ul_sr_info* ul_sr_info_msg);
  ::protocol::flex_ul_sr_info* unsafe_arena_release_ul_sr_info_msg();

  // .protocol.flex_enb_config_request enb_config_request_msg = 8;
  bool has_enb_config_request_msg() const;
  private:
  bool _internal_has_enb_config_request_msg() const;
  public:
  void clear_enb_config_request_msg();
  const ::protocol::flex_enb_config_request& enb_config_request_msg() const;
  ::protocol::flex_enb_config_request* release_enb_config_request_msg();
  ::protocol::flex_enb_config_request* mutable_enb_config_request_msg();
  void set_allocated_enb_config_request_msg(::protocol::flex_enb_config_request* enb_config_request_msg);
  private:
  const ::protocol::flex_enb_config_request& _internal_enb_config_request_msg() const;
  ::protocol::flex_enb_config_request* _internal_mutable_enb_config_request_msg();
  public:
  void unsafe_arena_set_allocated_enb_config_request_msg(
      ::protocol::flex_enb_config_request* enb_config_request_msg);
  ::protocol::flex_enb_config_request* unsafe_arena_release_enb_config_request_msg();

  // .protocol.flex_enb_config_reply enb_config_reply_msg = 9;
  bool has_enb_config_reply_msg() const;
  private:
  bool _internal_has_enb_config_reply_msg() const;
  public:
  void clear_enb_config_reply_msg();
  const ::protocol::flex_enb_config_reply& enb_config_reply_msg() const;
  ::protocol::flex_enb_config_reply* release_enb_config_reply_msg();
  ::protocol::flex_enb_config_reply* mutable_enb_config_reply_msg();
  void set_allocated_enb_config_reply_msg(::protocol::flex_enb_config_reply* enb_config_reply_msg);
  private:
  const ::protocol::flex_enb_config_reply& _internal_enb_config_reply_msg() const;
  ::protocol::flex_enb_config_reply* _internal_mutable_enb_config_reply_msg();
  public:
  void unsafe_arena_set_allocated_enb_config_reply_msg(
      ::protocol::flex_enb_config_reply* enb_config_reply_msg);
  ::protocol::flex_enb_config_reply* unsafe_arena_release_enb_config_reply_msg();

  // .protocol.flex_ue_config_request ue_config_request_msg = 10;
  bool has_ue_config_request_msg() const;
  private:
  bool _internal_has_ue_config_request_msg() const;
  public:
  void clear_ue_config_request_msg();
  const ::protocol::flex_ue_config_request& ue_config_request_msg() const;
  ::protocol::flex_ue_config_request* release_ue_config_request_msg();
  ::protocol::flex_ue_config_request* mutable_ue_config_request_msg();
  void set_allocated_ue_config_request_msg(::protocol::flex_ue_config_request* ue_config_request_msg);
  private:
  const ::protocol::flex_ue_config_request& _internal_ue_config_request_msg() const;
  ::protocol::flex_ue_config_request* _internal_mutable_ue_config_request_msg();
  public:
  void unsafe_arena_set_allocated_ue_config_request_msg(
      ::protocol::flex_ue_config_request* ue_config_request_msg);
  ::protocol::flex_ue_config_request* unsafe_arena_release_ue_config_request_msg();

  // .protocol.flex_ue_config_reply ue_config_reply_msg = 11;
  bool has_ue_config_reply_msg() const;
  private:
  bool _internal_has_ue_config_reply_msg() const;
  public:
  void clear_ue_config_reply_msg();
  const ::protocol::flex_ue_config_reply& ue_config_reply_msg() const;
  ::protocol::flex_ue_config_reply* release_ue_config_reply_msg();
  ::protocol::flex_ue_config_reply* mutable_ue_config_reply_msg();
  void set_allocated_ue_config_reply_msg(::protocol::flex_ue_config_reply* ue_config_reply_msg);
  private:
  const ::protocol::flex_ue_config_reply& _internal_ue_config_reply_msg() const;
  ::protocol::flex_ue_config_reply* _internal_mutable_ue_config_reply_msg();
  public:
  void unsafe_arena_set_allocated_ue_config_reply_msg(
      ::protocol::flex_ue_config_reply* ue_config_reply_msg);
  ::protocol::flex_ue_config_reply* unsafe_arena_release_ue_config_reply_msg();

  // .protocol.flex_lc_config_request lc_config_request_msg = 12;
  bool has_lc_config_request_msg() const;
  private:
  bool _internal_has_lc_config_request_msg() const;
  public:
  void clear_lc_config_request_msg();
  const ::protocol::flex_lc_config_request& lc_config_request_msg() const;
  ::protocol::flex_lc_config_request* release_lc_config_request_msg();
  ::protocol::flex_lc_config_request* mutable_lc_config_request_msg();
  void set_allocated_lc_config_request_msg(::protocol::flex_lc_config_request* lc_config_request_msg);
  private:
  const ::protocol::flex_lc_config_request& _internal_lc_config_request_msg() const;
  ::protocol::flex_lc_config_request* _internal_mutable_lc_config_request_msg();
  public:
  void unsafe_arena_set_allocated_lc_config_request_msg(
      ::protocol::flex_lc_config_request* lc_config_request_msg);
  ::protocol::flex_lc_config_request* unsafe_arena_release_lc_config_request_msg();

  // .protocol.flex_lc_config_reply lc_config_reply_msg = 13;
  bool has_lc_config_reply_msg() const;
  private:
  bool _internal_has_lc_config_reply_msg() const;
  public:
  void clear_lc_config_reply_msg();
  const ::protocol::flex_lc_config_reply& lc_config_reply_msg() const;
  ::protocol::flex_lc_config_reply* release_lc_config_reply_msg();
  ::protocol::flex_lc_config_reply* mutable_lc_config_reply_msg();
  void set_allocated_lc_config_reply_msg(::protocol::flex_lc_config_reply* lc_config_reply_msg);
  private:
  const ::protocol::flex_lc_config_reply& _internal_lc_config_reply_msg() const;
  ::protocol::flex_lc_config_reply* _internal_mutable_lc_config_reply_msg();
  public:
  void unsafe_arena_set_allocated_lc_config_reply_msg(
      ::protocol::flex_lc_config_reply* lc_config_reply_msg);
  ::protocol::flex_lc_config_reply* unsafe_arena_release_lc_config_reply_msg();

  // .protocol.flex_dl_mac_config dl_mac_config_msg = 14;
  bool has_dl_mac_config_msg() const;
  private:
  bool _internal_has_dl_mac_config_msg() const;
  public:
  void clear_dl_mac_config_msg();
  const ::protocol::flex_dl_mac_config& dl_mac_config_msg() const;
  ::protocol::flex_dl_mac_config* release_dl_mac_config_msg();
  ::protocol::flex_dl_mac_config* mutable_dl_mac_config_msg();
  void set_allocated_dl_mac_config_msg(::protocol::flex_dl_mac_config* dl_mac_config_msg);
  private:
  const ::protocol::flex_dl_mac_config& _internal_dl_mac_config_msg() const;
  ::protocol::flex_dl_mac_config* _internal_mutable_dl_mac_config_msg();
  public:
  void unsafe_arena_set_allocated_dl_mac_config_msg(
      ::protocol::flex_dl_mac_config* dl_mac_config_msg);
  ::protocol::flex_dl_mac_config* unsafe_arena_release_dl_mac_config_msg();

  // .protocol.flex_ue_state_change ue_state_change_msg = 15;
  bool has_ue_state_change_msg() const;
  private:
  bool _internal_has_ue_state_change_msg() const;
  public:
  void clear_ue_state_change_msg();
  const ::protocol::flex_ue_state_change& ue_state_change_msg() const;
  ::protocol::flex_ue_state_change* release_ue_state_change_msg();
  ::protocol::flex_ue_state_change* mutable_ue_state_change_msg();
  void set_allocated_ue_state_change_msg(::protocol::flex_ue_state_change* ue_state_change_msg);
  private:
  const ::protocol::flex_ue_state_change& _internal_ue_state_change_msg() const;
  ::protocol::flex_ue_state_change* _internal_mutable_ue_state_change_msg();
  public:
  void unsafe_arena_set_allocated_ue_state_change_msg(
      ::protocol::flex_ue_state_change* ue_state_change_msg);
  ::protocol::flex_ue_state_change* unsafe_arena_release_ue_state_change_msg();

  // .protocol.flex_control_delegation control_delegation_msg = 16;
  bool has_control_delegation_msg() const;
  private:
  bool _internal_has_control_delegation_msg() const;
  public:
  void clear_control_delegation_msg();
  const ::protocol::flex_control_delegation& control_delegation_msg() const;
  ::protocol::flex_control_delegation* release_control_delegation_msg();
  ::protocol::flex_control_delegation* mutable_control_delegation_msg();
  void set_allocated_control_delegation_msg(::protocol::flex_control_delegation* control_delegation_msg);
  private:
  const ::protocol::flex_control_delegation& _internal_control_delegation_msg() const;
  ::protocol::flex_control_delegation* _internal_mutable_control_delegation_msg();
  public:
  void unsafe_arena_set_allocated_control_delegation_msg(
      ::protocol::flex_control_delegation* control_delegation_msg);
  ::protocol::flex_control_delegation* unsafe_arena_release_control_delegation_msg();

  // .protocol.flex_agent_reconfiguration agent_reconfiguration_msg = 17;
  bool has_agent_reconfiguration_msg() const;
  private:
  bool _internal_has_agent_reconfiguration_msg() const;
  public:
  void clear_agent_reconfiguration_msg();
  const ::protocol::flex_agent_reconfiguration& agent_reconfiguration_msg() const;
  ::protocol::flex_agent_reconfiguration* release_agent_reconfiguration_msg();
  ::protocol::flex_agent_reconfiguration* mutable_agent_reconfiguration_msg();
  void set_allocated_agent_reconfiguration_msg(::protocol::flex_agent_reconfiguration* agent_reconfiguration_msg);
  private:
  const ::protocol::flex_agent_reconfiguration& _internal_agent_reconfiguration_msg() const;
  ::protocol::flex_agent_reconfiguration* _internal_mutable_agent_reconfiguration_msg();
  public:
  void unsafe_arena_set_allocated_agent_reconfiguration_msg(
      ::protocol::flex_agent_reconfiguration* agent_reconfiguration_msg);
  ::protocol::flex_agent_reconfiguration* unsafe_arena_release_agent_reconfiguration_msg();

  // .protocol.flex_rrc_triggering rrc_triggering = 18;
  bool has_rrc_triggering() const;
  private:
  bool _internal_has_rrc_triggering() const;
  public:
  void clear_rrc_triggering();
  const ::protocol::flex_rrc_triggering& rrc_triggering() const;
  ::protocol::flex_rrc_triggering* release_rrc_triggering();
  ::protocol::flex_rrc_triggering* mutable_rrc_triggering();
  void set_allocated_rrc_triggering(::protocol::flex_rrc_triggering* rrc_triggering);
  private:
  const ::protocol::flex_rrc_triggering& _internal_rrc_triggering() const;
  ::protocol::flex_rrc_triggering* _internal_mutable_rrc_triggering();
  public:
  void unsafe_arena_set_allocated_rrc_triggering(
      ::protocol::flex_rrc_triggering* rrc_triggering);
  ::protocol::flex_rrc_triggering* unsafe_arena_release_rrc_triggering();

  // .protocol.flex_ul_mac_config ul_mac_config_msg = 19;
  bool has_ul_mac_config_msg() const;
  private:
  bool _internal_has_ul_mac_config_msg() const;
  public:
  void clear_ul_mac_config_msg();
  const ::protocol::flex_ul_mac_config& ul_mac_config_msg() const;
  ::protocol::flex_ul_mac_config* release_ul_mac_config_msg();
  ::protocol::flex_ul_mac_config* mutable_ul_mac_config_msg();
  void set_allocated_ul_mac_config_msg(::protocol::flex_ul_mac_config* ul_mac_config_msg);
  private:
  const ::protocol::flex_ul_mac_config& _internal_ul_mac_config_msg() const;
  ::protocol::flex_ul_mac_config* _internal_mutable_ul_mac_config_msg();
  public:
  void unsafe_arena_set_allocated_ul_mac_config_msg(
      ::protocol::flex_ul_mac_config* ul_mac_config_msg);
  ::protocol::flex_ul_mac_config* unsafe_arena_release_ul_mac_config_msg();

  // .protocol.flex_disconnect disconnect_msg = 20;
  bool has_disconnect_msg() const;
  private:
  bool _internal_has_disconnect_msg() const;
  public:
  void clear_disconnect_msg();
  const ::protocol::flex_disconnect& disconnect_msg() const;
  ::protocol::flex_disconnect* release_disconnect_msg();
  ::protocol::flex_disconnect* mutable_disconnect_msg();
  void set_allocated_disconnect_msg(::protocol::flex_disconnect* disconnect_msg);
  private:
  const ::protocol::flex_disconnect& _internal_disconnect_msg() const;
  ::protocol::flex_disconnect* _internal_mutable_disconnect_msg();
  public:
  void unsafe_arena_set_allocated_disconnect_msg(
      ::protocol::flex_disconnect* disconnect_msg);
  ::protocol::flex_disconnect* unsafe_arena_release_disconnect_msg();

  // .protocol.flex_ho_command ho_command = 21;
  bool has_ho_command() const;
  private:
  bool _internal_has_ho_command() const;
  public:
  void clear_ho_command();
  const ::protocol::flex_ho_command& ho_command() const;
  ::protocol::flex_ho_command* release_ho_command();
  ::protocol::flex_ho_command* mutable_ho_command();
  void set_allocated_ho_command(::protocol::flex_ho_command* ho_command);
  private:
  const ::protocol::flex_ho_command& _internal_ho_command() const;
  ::protocol::flex_ho_command* _internal_mutable_ho_command();
  public:
  void unsafe_arena_set_allocated_ho_command(
      ::protocol::flex_ho_command* ho_command);
  ::protocol::flex_ho_command* unsafe_arena_release_ho_command();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:protocol.flexran_message)
 private:
  class _Internal;
  void set_has_hello_msg();
  void set_has_echo_request_msg();
  void set_has_echo_reply_msg();
  void set_has_stats_request_msg();
  void set_has_stats_reply_msg();
  void set_has_sf_trigger_msg();
  void set_has_ul_sr_info_msg();
  void set_has_enb_config_request_msg();
  void set_has_enb_config_reply_msg();
  void set_has_ue_config_request_msg();
  void set_has_ue_config_reply_msg();
  void set_has_lc_config_request_msg();
  void set_has_lc_config_reply_msg();
  void set_has_dl_mac_config_msg();
  void set_has_ue_state_change_msg();
  void set_has_control_delegation_msg();
  void set_has_agent_reconfiguration_msg();
  void set_has_rrc_triggering();
  void set_has_ul_mac_config_msg();
  void set_has_disconnect_msg();
  void set_has_ho_command();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int msg_dir_;
  union MsgUnion {
    MsgUnion() {}
    ::protocol::flex_hello* hello_msg_;
    ::protocol::flex_echo_request* echo_request_msg_;
    ::protocol::flex_echo_reply* echo_reply_msg_;
    ::protocol::flex_stats_request* stats_request_msg_;
    ::protocol::flex_stats_reply* stats_reply_msg_;
    ::protocol::flex_sf_trigger* sf_trigger_msg_;
    ::protocol::flex_ul_sr_info* ul_sr_info_msg_;
    ::protocol::flex_enb_config_request* enb_config_request_msg_;
    ::protocol::flex_enb_config_reply* enb_config_reply_msg_;
    ::protocol::flex_ue_config_request* ue_config_request_msg_;
    ::protocol::flex_ue_config_reply* ue_config_reply_msg_;
    ::protocol::flex_lc_config_request* lc_config_request_msg_;
    ::protocol::flex_lc_config_reply* lc_config_reply_msg_;
    ::protocol::flex_dl_mac_config* dl_mac_config_msg_;
    ::protocol::flex_ue_state_change* ue_state_change_msg_;
    ::protocol::flex_control_delegation* control_delegation_msg_;
    ::protocol::flex_agent_reconfiguration* agent_reconfiguration_msg_;
    ::protocol::flex_rrc_triggering* rrc_triggering_;
    ::protocol::flex_ul_mac_config* ul_mac_config_msg_;
    ::protocol::flex_disconnect* disconnect_msg_;
    ::protocol::flex_ho_command* ho_command_;
  } msg_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_hello PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_hello) */ {
 public:
  inline flex_hello() : flex_hello(nullptr) {}
  virtual ~flex_hello();

  flex_hello(const flex_hello& from);
  flex_hello(flex_hello&& from) noexcept
    : flex_hello() {
    *this = ::std::move(from);
  }

  inline flex_hello& operator=(const flex_hello& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_hello& operator=(flex_hello&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_hello& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_hello* internal_default_instance() {
    return reinterpret_cast<const flex_hello*>(
               &_flex_hello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(flex_hello& a, flex_hello& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_hello* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_hello* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_hello* New() const final {
    return CreateMaybeMessage<flex_hello>(nullptr);
  }

  flex_hello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_hello>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_hello& from);
  void MergeFrom(const flex_hello& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_hello* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_hello";
  }
  protected:
  explicit flex_hello(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 3,
    kSplitsFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kBsIdFieldNumber = 2,
  };
  // repeated .protocol.flex_bs_capability capabilities = 3;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  private:
  ::protocol::flex_bs_capability _internal_capabilities(int index) const;
  void _internal_add_capabilities(::protocol::flex_bs_capability value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_capabilities();
  public:
  ::protocol::flex_bs_capability capabilities(int index) const;
  void set_capabilities(int index, ::protocol::flex_bs_capability value);
  void add_capabilities(::protocol::flex_bs_capability value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_capabilities();

  // repeated .protocol.flex_bs_split splits = 4;
  int splits_size() const;
  private:
  int _internal_splits_size() const;
  public:
  void clear_splits();
  private:
  ::protocol::flex_bs_split _internal_splits(int index) const;
  void _internal_add_splits(::protocol::flex_bs_split value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_splits();
  public:
  ::protocol::flex_bs_split splits(int index) const;
  void set_splits(int index, ::protocol::flex_bs_split value);
  void add_splits(::protocol::flex_bs_split value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& splits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_splits();

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional uint64 bs_id = 2;
  bool has_bs_id() const;
  private:
  bool _internal_has_bs_id() const;
  public:
  void clear_bs_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 bs_id() const;
  void set_bs_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bs_id() const;
  void _internal_set_bs_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_hello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> capabilities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> splits_;
  ::protocol::flex_header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bs_id_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_echo_request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_request) */ {
 public:
  inline flex_echo_request() : flex_echo_request(nullptr) {}
  virtual ~flex_echo_request();

  flex_echo_request(const flex_echo_request& from);
  flex_echo_request(flex_echo_request&& from) noexcept
    : flex_echo_request() {
    *this = ::std::move(from);
  }

  inline flex_echo_request& operator=(const flex_echo_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_echo_request& operator=(flex_echo_request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_echo_request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_echo_request* internal_default_instance() {
    return reinterpret_cast<const flex_echo_request*>(
               &_flex_echo_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(flex_echo_request& a, flex_echo_request& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_echo_request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_echo_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_echo_request* New() const final {
    return CreateMaybeMessage<flex_echo_request>(nullptr);
  }

  flex_echo_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_echo_request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_echo_request& from);
  void MergeFrom(const flex_echo_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_echo_request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_echo_request";
  }
  protected:
  explicit flex_echo_request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(flex_echo_request)
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_request)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_echo_reply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_reply) */ {
 public:
  inline flex_echo_reply() : flex_echo_reply(nullptr) {}
  virtual ~flex_echo_reply();

  flex_echo_reply(const flex_echo_reply& from);
  flex_echo_reply(flex_echo_reply&& from) noexcept
    : flex_echo_reply() {
    *this = ::std::move(from);
  }

  inline flex_echo_reply& operator=(const flex_echo_reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_echo_reply& operator=(flex_echo_reply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_echo_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_echo_reply* internal_default_instance() {
    return reinterpret_cast<const flex_echo_reply*>(
               &_flex_echo_reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(flex_echo_reply& a, flex_echo_reply& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_echo_reply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_echo_reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_echo_reply* New() const final {
    return CreateMaybeMessage<flex_echo_reply>(nullptr);
  }

  flex_echo_reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_echo_reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_echo_reply& from);
  void MergeFrom(const flex_echo_reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_echo_reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_echo_reply";
  }
  protected:
  explicit flex_echo_reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(flex_echo_reply)
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_reply)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_stats_request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_stats_request) */ {
 public:
  inline flex_stats_request() : flex_stats_request(nullptr) {}
  virtual ~flex_stats_request();

  flex_stats_request(const flex_stats_request& from);
  flex_stats_request(flex_stats_request&& from) noexcept
    : flex_stats_request() {
    *this = ::std::move(from);
  }

  inline flex_stats_request& operator=(const flex_stats_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_stats_request& operator=(flex_stats_request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_stats_request& default_instance();

  enum BodyCase {
    kCompleteStatsRequest = 3,
    kCellStatsRequest = 4,
    kUeStatsRequest = 5,
    BODY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_stats_request* internal_default_instance() {
    return reinterpret_cast<const flex_stats_request*>(
               &_flex_stats_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(flex_stats_request& a, flex_stats_request& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_stats_request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_stats_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_stats_request* New() const final {
    return CreateMaybeMessage<flex_stats_request>(nullptr);
  }

  flex_stats_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_stats_request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_stats_request& from);
  void MergeFrom(const flex_stats_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_stats_request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_stats_request";
  }
  protected:
  explicit flex_stats_request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTypeFieldNumber = 2,
    kCompleteStatsRequestFieldNumber = 3,
    kCellStatsRequestFieldNumber = 4,
    kUeStatsRequestFieldNumber = 5,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional .protocol.flex_stats_type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::protocol::flex_stats_type type() const;
  void set_type(::protocol::flex_stats_type value);
  private:
  ::protocol::flex_stats_type _internal_type() const;
  void _internal_set_type(::protocol::flex_stats_type value);
  public:

  // .protocol.flex_complete_stats_request complete_stats_request = 3;
  bool has_complete_stats_request() const;
  private:
  bool _internal_has_complete_stats_request() const;
  public:
  void clear_complete_stats_request();
  const ::protocol::flex_complete_stats_request& complete_stats_request() const;
  ::protocol::flex_complete_stats_request* release_complete_stats_request();
  ::protocol::flex_complete_stats_request* mutable_complete_stats_request();
  void set_allocated_complete_stats_request(::protocol::flex_complete_stats_request* complete_stats_request);
  private:
  const ::protocol::flex_complete_stats_request& _internal_complete_stats_request() const;
  ::protocol::flex_complete_stats_request* _internal_mutable_complete_stats_request();
  public:
  void unsafe_arena_set_allocated_complete_stats_request(
      ::protocol::flex_complete_stats_request* complete_stats_request);
  ::protocol::flex_complete_stats_request* unsafe_arena_release_complete_stats_request();

  // .protocol.flex_cell_stats_request cell_stats_request = 4;
  bool has_cell_stats_request() const;
  private:
  bool _internal_has_cell_stats_request() const;
  public:
  void clear_cell_stats_request();
  const ::protocol::flex_cell_stats_request& cell_stats_request() const;
  ::protocol::flex_cell_stats_request* release_cell_stats_request();
  ::protocol::flex_cell_stats_request* mutable_cell_stats_request();
  void set_allocated_cell_stats_request(::protocol::flex_cell_stats_request* cell_stats_request);
  private:
  const ::protocol::flex_cell_stats_request& _internal_cell_stats_request() const;
  ::protocol::flex_cell_stats_request* _internal_mutable_cell_stats_request();
  public:
  void unsafe_arena_set_allocated_cell_stats_request(
      ::protocol::flex_cell_stats_request* cell_stats_request);
  ::protocol::flex_cell_stats_request* unsafe_arena_release_cell_stats_request();

  // .protocol.flex_ue_stats_request ue_stats_request = 5;
  bool has_ue_stats_request() const;
  private:
  bool _internal_has_ue_stats_request() const;
  public:
  void clear_ue_stats_request();
  const ::protocol::flex_ue_stats_request& ue_stats_request() const;
  ::protocol::flex_ue_stats_request* release_ue_stats_request();
  ::protocol::flex_ue_stats_request* mutable_ue_stats_request();
  void set_allocated_ue_stats_request(::protocol::flex_ue_stats_request* ue_stats_request);
  private:
  const ::protocol::flex_ue_stats_request& _internal_ue_stats_request() const;
  ::protocol::flex_ue_stats_request* _internal_mutable_ue_stats_request();
  public:
  void unsafe_arena_set_allocated_ue_stats_request(
      ::protocol::flex_ue_stats_request* ue_stats_request);
  ::protocol::flex_ue_stats_request* unsafe_arena_release_ue_stats_request();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:protocol.flex_stats_request)
 private:
  class _Internal;
  void set_has_complete_stats_request();
  void set_has_cell_stats_request();
  void set_has_ue_stats_request();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  int type_;
  union BodyUnion {
    BodyUnion() {}
    ::protocol::flex_complete_stats_request* complete_stats_request_;
    ::protocol::flex_cell_stats_request* cell_stats_request_;
    ::protocol::flex_ue_stats_request* ue_stats_request_;
  } body_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_stats_reply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_stats_reply) */ {
 public:
  inline flex_stats_reply() : flex_stats_reply(nullptr) {}
  virtual ~flex_stats_reply();

  flex_stats_reply(const flex_stats_reply& from);
  flex_stats_reply(flex_stats_reply&& from) noexcept
    : flex_stats_reply() {
    *this = ::std::move(from);
  }

  inline flex_stats_reply& operator=(const flex_stats_reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_stats_reply& operator=(flex_stats_reply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_stats_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_stats_reply* internal_default_instance() {
    return reinterpret_cast<const flex_stats_reply*>(
               &_flex_stats_reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(flex_stats_reply& a, flex_stats_reply& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_stats_reply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_stats_reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_stats_reply* New() const final {
    return CreateMaybeMessage<flex_stats_reply>(nullptr);
  }

  flex_stats_reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_stats_reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_stats_reply& from);
  void MergeFrom(const flex_stats_reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_stats_reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_stats_reply";
  }
  protected:
  explicit flex_stats_reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeReportFieldNumber = 2,
    kCellReportFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // repeated .protocol.flex_ue_stats_report ue_report = 2;
  int ue_report_size() const;
  private:
  int _internal_ue_report_size() const;
  public:
  void clear_ue_report();
  ::protocol::flex_ue_stats_report* mutable_ue_report(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_stats_report >*
      mutable_ue_report();
  private:
  const ::protocol::flex_ue_stats_report& _internal_ue_report(int index) const;
  ::protocol::flex_ue_stats_report* _internal_add_ue_report();
  public:
  const ::protocol::flex_ue_stats_report& ue_report(int index) const;
  ::protocol::flex_ue_stats_report* add_ue_report();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_stats_report >&
      ue_report() const;

  // repeated .protocol.flex_cell_stats_report cell_report = 3;
  int cell_report_size() const;
  private:
  int _internal_cell_report_size() const;
  public:
  void clear_cell_report();
  ::protocol::flex_cell_stats_report* mutable_cell_report(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_stats_report >*
      mutable_cell_report();
  private:
  const ::protocol::flex_cell_stats_report& _internal_cell_report(int index) const;
  ::protocol::flex_cell_stats_report* _internal_add_cell_report();
  public:
  const ::protocol::flex_cell_stats_report& cell_report(int index) const;
  ::protocol::flex_cell_stats_report* add_cell_report();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_stats_report >&
      cell_report() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_stats_reply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_stats_report > ue_report_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_stats_report > cell_report_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_sf_trigger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_sf_trigger) */ {
 public:
  inline flex_sf_trigger() : flex_sf_trigger(nullptr) {}
  virtual ~flex_sf_trigger();

  flex_sf_trigger(const flex_sf_trigger& from);
  flex_sf_trigger(flex_sf_trigger&& from) noexcept
    : flex_sf_trigger() {
    *this = ::std::move(from);
  }

  inline flex_sf_trigger& operator=(const flex_sf_trigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_sf_trigger& operator=(flex_sf_trigger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_sf_trigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_sf_trigger* internal_default_instance() {
    return reinterpret_cast<const flex_sf_trigger*>(
               &_flex_sf_trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(flex_sf_trigger& a, flex_sf_trigger& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_sf_trigger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_sf_trigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_sf_trigger* New() const final {
    return CreateMaybeMessage<flex_sf_trigger>(nullptr);
  }

  flex_sf_trigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_sf_trigger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_sf_trigger& from);
  void MergeFrom(const flex_sf_trigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_sf_trigger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_sf_trigger";
  }
  protected:
  explicit flex_sf_trigger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDlInfoFieldNumber = 3,
    kUlInfoFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSfnSfFieldNumber = 2,
  };
  // repeated .protocol.flex_dl_info dl_info = 3;
  int dl_info_size() const;
  private:
  int _internal_dl_info_size() const;
  public:
  void clear_dl_info();
  ::protocol::flex_dl_info* mutable_dl_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_info >*
      mutable_dl_info();
  private:
  const ::protocol::flex_dl_info& _internal_dl_info(int index) const;
  ::protocol::flex_dl_info* _internal_add_dl_info();
  public:
  const ::protocol::flex_dl_info& dl_info(int index) const;
  ::protocol::flex_dl_info* add_dl_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_info >&
      dl_info() const;

  // repeated .protocol.flex_ul_info ul_info = 4;
  int ul_info_size() const;
  private:
  int _internal_ul_info_size() const;
  public:
  void clear_ul_info();
  ::protocol::flex_ul_info* mutable_ul_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_info >*
      mutable_ul_info();
  private:
  const ::protocol::flex_ul_info& _internal_ul_info(int index) const;
  ::protocol::flex_ul_info* _internal_add_ul_info();
  public:
  const ::protocol::flex_ul_info& ul_info(int index) const;
  ::protocol::flex_ul_info* add_ul_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_info >&
      ul_info() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  private:
  bool _internal_has_sfn_sf() const;
  public:
  void clear_sfn_sf();
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf() const;
  void set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sfn_sf() const;
  void _internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_sf_trigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_info > dl_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_info > ul_info_;
  ::protocol::flex_header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_ul_sr_info PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ul_sr_info) */ {
 public:
  inline flex_ul_sr_info() : flex_ul_sr_info(nullptr) {}
  virtual ~flex_ul_sr_info();

  flex_ul_sr_info(const flex_ul_sr_info& from);
  flex_ul_sr_info(flex_ul_sr_info&& from) noexcept
    : flex_ul_sr_info() {
    *this = ::std::move(from);
  }

  inline flex_ul_sr_info& operator=(const flex_ul_sr_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_ul_sr_info& operator=(flex_ul_sr_info&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_ul_sr_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_ul_sr_info* internal_default_instance() {
    return reinterpret_cast<const flex_ul_sr_info*>(
               &_flex_ul_sr_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(flex_ul_sr_info& a, flex_ul_sr_info& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_ul_sr_info* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_ul_sr_info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_ul_sr_info* New() const final {
    return CreateMaybeMessage<flex_ul_sr_info>(nullptr);
  }

  flex_ul_sr_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_ul_sr_info>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_ul_sr_info& from);
  void MergeFrom(const flex_ul_sr_info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_ul_sr_info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_ul_sr_info";
  }
  protected:
  explicit flex_ul_sr_info(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRntiFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kSfnSfFieldNumber = 2,
  };
  // repeated uint32 rnti = 3;
  int rnti_size() const;
  private:
  int _internal_rnti_size() const;
  public:
  void clear_rnti();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_rnti(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_rnti() const;
  void _internal_add_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_rnti();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 rnti(int index) const;
  void set_rnti(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      rnti() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_rnti();

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  private:
  bool _internal_has_sfn_sf() const;
  public:
  void clear_sfn_sf();
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf() const;
  void set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sfn_sf() const;
  void _internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_ul_sr_info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > rnti_;
  ::protocol::flex_header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_enb_config_request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_enb_config_request) */ {
 public:
  inline flex_enb_config_request() : flex_enb_config_request(nullptr) {}
  virtual ~flex_enb_config_request();

  flex_enb_config_request(const flex_enb_config_request& from);
  flex_enb_config_request(flex_enb_config_request&& from) noexcept
    : flex_enb_config_request() {
    *this = ::std::move(from);
  }

  inline flex_enb_config_request& operator=(const flex_enb_config_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_enb_config_request& operator=(flex_enb_config_request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_enb_config_request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_enb_config_request* internal_default_instance() {
    return reinterpret_cast<const flex_enb_config_request*>(
               &_flex_enb_config_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(flex_enb_config_request& a, flex_enb_config_request& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_enb_config_request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_enb_config_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_enb_config_request* New() const final {
    return CreateMaybeMessage<flex_enb_config_request>(nullptr);
  }

  flex_enb_config_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_enb_config_request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_enb_config_request& from);
  void MergeFrom(const flex_enb_config_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_enb_config_request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_enb_config_request";
  }
  protected:
  explicit flex_enb_config_request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_enb_config_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_enb_config_reply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_enb_config_reply) */ {
 public:
  inline flex_enb_config_reply() : flex_enb_config_reply(nullptr) {}
  virtual ~flex_enb_config_reply();

  flex_enb_config_reply(const flex_enb_config_reply& from);
  flex_enb_config_reply(flex_enb_config_reply&& from) noexcept
    : flex_enb_config_reply() {
    *this = ::std::move(from);
  }

  inline flex_enb_config_reply& operator=(const flex_enb_config_reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_enb_config_reply& operator=(flex_enb_config_reply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_enb_config_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_enb_config_reply* internal_default_instance() {
    return reinterpret_cast<const flex_enb_config_reply*>(
               &_flex_enb_config_reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(flex_enb_config_reply& a, flex_enb_config_reply& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_enb_config_reply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_enb_config_reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_enb_config_reply* New() const final {
    return CreateMaybeMessage<flex_enb_config_reply>(nullptr);
  }

  flex_enb_config_reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_enb_config_reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_enb_config_reply& from);
  void MergeFrom(const flex_enb_config_reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_enb_config_reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_enb_config_reply";
  }
  protected:
  explicit flex_enb_config_reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellConfigFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kS1ApFieldNumber = 5,
    kENBIdFieldNumber = 2,
    kDeviceSpecFieldNumber = 4,
  };
  // repeated .protocol.flex_cell_config cell_config = 3;
  int cell_config_size() const;
  private:
  int _internal_cell_config_size() const;
  public:
  void clear_cell_config();
  ::protocol::flex_cell_config* mutable_cell_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_config >*
      mutable_cell_config();
  private:
  const ::protocol::flex_cell_config& _internal_cell_config(int index) const;
  ::protocol::flex_cell_config* _internal_add_cell_config();
  public:
  const ::protocol::flex_cell_config& cell_config(int index) const;
  ::protocol::flex_cell_config* add_cell_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_config >&
      cell_config() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional .protocol.flex_s1ap_config s1ap = 5;
  bool has_s1ap() const;
  private:
  bool _internal_has_s1ap() const;
  public:
  void clear_s1ap();
  const ::protocol::flex_s1ap_config& s1ap() const;
  ::protocol::flex_s1ap_config* release_s1ap();
  ::protocol::flex_s1ap_config* mutable_s1ap();
  void set_allocated_s1ap(::protocol::flex_s1ap_config* s1ap);
  private:
  const ::protocol::flex_s1ap_config& _internal_s1ap() const;
  ::protocol::flex_s1ap_config* _internal_mutable_s1ap();
  public:
  void unsafe_arena_set_allocated_s1ap(
      ::protocol::flex_s1ap_config* s1ap);
  ::protocol::flex_s1ap_config* unsafe_arena_release_s1ap();

  // optional uint64 eNB_id = 2;
  bool has_enb_id() const;
  private:
  bool _internal_has_enb_id() const;
  public:
  void clear_enb_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 enb_id() const;
  void set_enb_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_enb_id() const;
  void _internal_set_enb_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 device_spec = 4;
  bool has_device_spec() const;
  private:
  bool _internal_has_device_spec() const;
  public:
  void clear_device_spec();
  ::PROTOBUF_NAMESPACE_ID::uint32 device_spec() const;
  void set_device_spec(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_device_spec() const;
  void _internal_set_device_spec(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_enb_config_reply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_config > cell_config_;
  ::protocol::flex_header* header_;
  ::protocol::flex_s1ap_config* s1ap_;
  ::PROTOBUF_NAMESPACE_ID::uint64 enb_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 device_spec_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_ue_config_request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ue_config_request) */ {
 public:
  inline flex_ue_config_request() : flex_ue_config_request(nullptr) {}
  virtual ~flex_ue_config_request();

  flex_ue_config_request(const flex_ue_config_request& from);
  flex_ue_config_request(flex_ue_config_request&& from) noexcept
    : flex_ue_config_request() {
    *this = ::std::move(from);
  }

  inline flex_ue_config_request& operator=(const flex_ue_config_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_ue_config_request& operator=(flex_ue_config_request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_ue_config_request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_ue_config_request* internal_default_instance() {
    return reinterpret_cast<const flex_ue_config_request*>(
               &_flex_ue_config_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(flex_ue_config_request& a, flex_ue_config_request& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_ue_config_request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_ue_config_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_ue_config_request* New() const final {
    return CreateMaybeMessage<flex_ue_config_request>(nullptr);
  }

  flex_ue_config_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_ue_config_request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_ue_config_request& from);
  void MergeFrom(const flex_ue_config_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_ue_config_request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_ue_config_request";
  }
  protected:
  explicit flex_ue_config_request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_ue_config_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_ue_config_reply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ue_config_reply) */ {
 public:
  inline flex_ue_config_reply() : flex_ue_config_reply(nullptr) {}
  virtual ~flex_ue_config_reply();

  flex_ue_config_reply(const flex_ue_config_reply& from);
  flex_ue_config_reply(flex_ue_config_reply&& from) noexcept
    : flex_ue_config_reply() {
    *this = ::std::move(from);
  }

  inline flex_ue_config_reply& operator=(const flex_ue_config_reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_ue_config_reply& operator=(flex_ue_config_reply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_ue_config_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_ue_config_reply* internal_default_instance() {
    return reinterpret_cast<const flex_ue_config_reply*>(
               &_flex_ue_config_reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(flex_ue_config_reply& a, flex_ue_config_reply& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_ue_config_reply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_ue_config_reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_ue_config_reply* New() const final {
    return CreateMaybeMessage<flex_ue_config_reply>(nullptr);
  }

  flex_ue_config_reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_ue_config_reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_ue_config_reply& from);
  void MergeFrom(const flex_ue_config_reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_ue_config_reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_ue_config_reply";
  }
  protected:
  explicit flex_ue_config_reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeConfigFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .protocol.flex_ue_config ue_config = 2;
  int ue_config_size() const;
  private:
  int _internal_ue_config_size() const;
  public:
  void clear_ue_config();
  ::protocol::flex_ue_config* mutable_ue_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_config >*
      mutable_ue_config();
  private:
  const ::protocol::flex_ue_config& _internal_ue_config(int index) const;
  ::protocol::flex_ue_config* _internal_add_ue_config();
  public:
  const ::protocol::flex_ue_config& ue_config(int index) const;
  ::protocol::flex_ue_config* add_ue_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_config >&
      ue_config() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_ue_config_reply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_config > ue_config_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_lc_config_request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_lc_config_request) */ {
 public:
  inline flex_lc_config_request() : flex_lc_config_request(nullptr) {}
  virtual ~flex_lc_config_request();

  flex_lc_config_request(const flex_lc_config_request& from);
  flex_lc_config_request(flex_lc_config_request&& from) noexcept
    : flex_lc_config_request() {
    *this = ::std::move(from);
  }

  inline flex_lc_config_request& operator=(const flex_lc_config_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_lc_config_request& operator=(flex_lc_config_request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_lc_config_request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_lc_config_request* internal_default_instance() {
    return reinterpret_cast<const flex_lc_config_request*>(
               &_flex_lc_config_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(flex_lc_config_request& a, flex_lc_config_request& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_lc_config_request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_lc_config_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_lc_config_request* New() const final {
    return CreateMaybeMessage<flex_lc_config_request>(nullptr);
  }

  flex_lc_config_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_lc_config_request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_lc_config_request& from);
  void MergeFrom(const flex_lc_config_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_lc_config_request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_lc_config_request";
  }
  protected:
  explicit flex_lc_config_request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_lc_config_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_lc_config_reply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_lc_config_reply) */ {
 public:
  inline flex_lc_config_reply() : flex_lc_config_reply(nullptr) {}
  virtual ~flex_lc_config_reply();

  flex_lc_config_reply(const flex_lc_config_reply& from);
  flex_lc_config_reply(flex_lc_config_reply&& from) noexcept
    : flex_lc_config_reply() {
    *this = ::std::move(from);
  }

  inline flex_lc_config_reply& operator=(const flex_lc_config_reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_lc_config_reply& operator=(flex_lc_config_reply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_lc_config_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_lc_config_reply* internal_default_instance() {
    return reinterpret_cast<const flex_lc_config_reply*>(
               &_flex_lc_config_reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(flex_lc_config_reply& a, flex_lc_config_reply& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_lc_config_reply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_lc_config_reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_lc_config_reply* New() const final {
    return CreateMaybeMessage<flex_lc_config_reply>(nullptr);
  }

  flex_lc_config_reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_lc_config_reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_lc_config_reply& from);
  void MergeFrom(const flex_lc_config_reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_lc_config_reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_lc_config_reply";
  }
  protected:
  explicit flex_lc_config_reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLcUeConfigFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .protocol.flex_lc_ue_config lc_ue_config = 2;
  int lc_ue_config_size() const;
  private:
  int _internal_lc_ue_config_size() const;
  public:
  void clear_lc_ue_config();
  ::protocol::flex_lc_ue_config* mutable_lc_ue_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_lc_ue_config >*
      mutable_lc_ue_config();
  private:
  const ::protocol::flex_lc_ue_config& _internal_lc_ue_config(int index) const;
  ::protocol::flex_lc_ue_config* _internal_add_lc_ue_config();
  public:
  const ::protocol::flex_lc_ue_config& lc_ue_config(int index) const;
  ::protocol::flex_lc_ue_config* add_lc_ue_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_lc_ue_config >&
      lc_ue_config() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_lc_config_reply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_lc_ue_config > lc_ue_config_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_dl_mac_config PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_dl_mac_config) */ {
 public:
  inline flex_dl_mac_config() : flex_dl_mac_config(nullptr) {}
  virtual ~flex_dl_mac_config();

  flex_dl_mac_config(const flex_dl_mac_config& from);
  flex_dl_mac_config(flex_dl_mac_config&& from) noexcept
    : flex_dl_mac_config() {
    *this = ::std::move(from);
  }

  inline flex_dl_mac_config& operator=(const flex_dl_mac_config& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_dl_mac_config& operator=(flex_dl_mac_config&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_dl_mac_config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_dl_mac_config* internal_default_instance() {
    return reinterpret_cast<const flex_dl_mac_config*>(
               &_flex_dl_mac_config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(flex_dl_mac_config& a, flex_dl_mac_config& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_dl_mac_config* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_dl_mac_config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_dl_mac_config* New() const final {
    return CreateMaybeMessage<flex_dl_mac_config>(nullptr);
  }

  flex_dl_mac_config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_dl_mac_config>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_dl_mac_config& from);
  void MergeFrom(const flex_dl_mac_config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_dl_mac_config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_dl_mac_config";
  }
  protected:
  explicit flex_dl_mac_config(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDlUeDataFieldNumber = 3,
    kDlRarFieldNumber = 4,
    kDlBroadcastFieldNumber = 5,
    kOfdmSymFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kSfnSfFieldNumber = 2,
  };
  // repeated .protocol.flex_dl_data dl_ue_data = 3;
  int dl_ue_data_size() const;
  private:
  int _internal_dl_ue_data_size() const;
  public:
  void clear_dl_ue_data();
  ::protocol::flex_dl_data* mutable_dl_ue_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_data >*
      mutable_dl_ue_data();
  private:
  const ::protocol::flex_dl_data& _internal_dl_ue_data(int index) const;
  ::protocol::flex_dl_data* _internal_add_dl_ue_data();
  public:
  const ::protocol::flex_dl_data& dl_ue_data(int index) const;
  ::protocol::flex_dl_data* add_dl_ue_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_data >&
      dl_ue_data() const;

  // repeated .protocol.flex_dl_rar dl_rar = 4;
  int dl_rar_size() const;
  private:
  int _internal_dl_rar_size() const;
  public:
  void clear_dl_rar();
  ::protocol::flex_dl_rar* mutable_dl_rar(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_rar >*
      mutable_dl_rar();
  private:
  const ::protocol::flex_dl_rar& _internal_dl_rar(int index) const;
  ::protocol::flex_dl_rar* _internal_add_dl_rar();
  public:
  const ::protocol::flex_dl_rar& dl_rar(int index) const;
  ::protocol::flex_dl_rar* add_dl_rar();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_rar >&
      dl_rar() const;

  // repeated .protocol.flex_dl_broadcast dl_broadcast = 5;
  int dl_broadcast_size() const;
  private:
  int _internal_dl_broadcast_size() const;
  public:
  void clear_dl_broadcast();
  ::protocol::flex_dl_broadcast* mutable_dl_broadcast(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_broadcast >*
      mutable_dl_broadcast();
  private:
  const ::protocol::flex_dl_broadcast& _internal_dl_broadcast(int index) const;
  ::protocol::flex_dl_broadcast* _internal_add_dl_broadcast();
  public:
  const ::protocol::flex_dl_broadcast& dl_broadcast(int index) const;
  ::protocol::flex_dl_broadcast* add_dl_broadcast();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_broadcast >&
      dl_broadcast() const;

  // repeated .protocol.flex_pdcch_ofdm_sym_count ofdm_sym = 6;
  int ofdm_sym_size() const;
  private:
  int _internal_ofdm_sym_size() const;
  public:
  void clear_ofdm_sym();
  ::protocol::flex_pdcch_ofdm_sym_count* mutable_ofdm_sym(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >*
      mutable_ofdm_sym();
  private:
  const ::protocol::flex_pdcch_ofdm_sym_count& _internal_ofdm_sym(int index) const;
  ::protocol::flex_pdcch_ofdm_sym_count* _internal_add_ofdm_sym();
  public:
  const ::protocol::flex_pdcch_ofdm_sym_count& ofdm_sym(int index) const;
  ::protocol::flex_pdcch_ofdm_sym_count* add_ofdm_sym();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >&
      ofdm_sym() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  private:
  bool _internal_has_sfn_sf() const;
  public:
  void clear_sfn_sf();
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf() const;
  void set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sfn_sf() const;
  void _internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_dl_mac_config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_data > dl_ue_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_rar > dl_rar_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_broadcast > dl_broadcast_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count > ofdm_sym_;
  ::protocol::flex_header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_ul_mac_config PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ul_mac_config) */ {
 public:
  inline flex_ul_mac_config() : flex_ul_mac_config(nullptr) {}
  virtual ~flex_ul_mac_config();

  flex_ul_mac_config(const flex_ul_mac_config& from);
  flex_ul_mac_config(flex_ul_mac_config&& from) noexcept
    : flex_ul_mac_config() {
    *this = ::std::move(from);
  }

  inline flex_ul_mac_config& operator=(const flex_ul_mac_config& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_ul_mac_config& operator=(flex_ul_mac_config&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_ul_mac_config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_ul_mac_config* internal_default_instance() {
    return reinterpret_cast<const flex_ul_mac_config*>(
               &_flex_ul_mac_config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(flex_ul_mac_config& a, flex_ul_mac_config& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_ul_mac_config* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_ul_mac_config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_ul_mac_config* New() const final {
    return CreateMaybeMessage<flex_ul_mac_config>(nullptr);
  }

  flex_ul_mac_config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_ul_mac_config>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_ul_mac_config& from);
  void MergeFrom(const flex_ul_mac_config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_ul_mac_config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_ul_mac_config";
  }
  protected:
  explicit flex_ul_mac_config(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUlUeDataFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kSfnSfFieldNumber = 2,
  };
  // repeated .protocol.flex_ul_data ul_ue_data = 3;
  int ul_ue_data_size() const;
  private:
  int _internal_ul_ue_data_size() const;
  public:
  void clear_ul_ue_data();
  ::protocol::flex_ul_data* mutable_ul_ue_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_data >*
      mutable_ul_ue_data();
  private:
  const ::protocol::flex_ul_data& _internal_ul_ue_data(int index) const;
  ::protocol::flex_ul_data* _internal_add_ul_ue_data();
  public:
  const ::protocol::flex_ul_data& ul_ue_data(int index) const;
  ::protocol::flex_ul_data* add_ul_ue_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_data >&
      ul_ue_data() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  private:
  bool _internal_has_sfn_sf() const;
  public:
  void clear_sfn_sf();
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf() const;
  void set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sfn_sf() const;
  void _internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_ul_mac_config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_data > ul_ue_data_;
  ::protocol::flex_header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sfn_sf_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_rrc_triggering PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_rrc_triggering) */ {
 public:
  inline flex_rrc_triggering() : flex_rrc_triggering(nullptr) {}
  virtual ~flex_rrc_triggering();

  flex_rrc_triggering(const flex_rrc_triggering& from);
  flex_rrc_triggering(flex_rrc_triggering&& from) noexcept
    : flex_rrc_triggering() {
    *this = ::std::move(from);
  }

  inline flex_rrc_triggering& operator=(const flex_rrc_triggering& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_rrc_triggering& operator=(flex_rrc_triggering&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_rrc_triggering& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_rrc_triggering* internal_default_instance() {
    return reinterpret_cast<const flex_rrc_triggering*>(
               &_flex_rrc_triggering_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(flex_rrc_triggering& a, flex_rrc_triggering& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_rrc_triggering* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_rrc_triggering* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_rrc_triggering* New() const final {
    return CreateMaybeMessage<flex_rrc_triggering>(nullptr);
  }

  flex_rrc_triggering* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_rrc_triggering>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_rrc_triggering& from);
  void MergeFrom(const flex_rrc_triggering& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_rrc_triggering* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_rrc_triggering";
  }
  protected:
  explicit flex_rrc_triggering(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRrcTriggerFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kMeasInfoFieldNumber = 3,
  };
  // optional string rrc_trigger = 2;
  bool has_rrc_trigger() const;
  private:
  bool _internal_has_rrc_trigger() const;
  public:
  void clear_rrc_trigger();
  const std::string& rrc_trigger() const;
  void set_rrc_trigger(const std::string& value);
  void set_rrc_trigger(std::string&& value);
  void set_rrc_trigger(const char* value);
  void set_rrc_trigger(const char* value, size_t size);
  std::string* mutable_rrc_trigger();
  std::string* release_rrc_trigger();
  void set_allocated_rrc_trigger(std::string* rrc_trigger);
  private:
  const std::string& _internal_rrc_trigger() const;
  void _internal_set_rrc_trigger(const std::string& value);
  std::string* _internal_mutable_rrc_trigger();
  public:

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional .protocol.flex_measurement_info meas_info = 3;
  bool has_meas_info() const;
  private:
  bool _internal_has_meas_info() const;
  public:
  void clear_meas_info();
  const ::protocol::flex_measurement_info& meas_info() const;
  ::protocol::flex_measurement_info* release_meas_info();
  ::protocol::flex_measurement_info* mutable_meas_info();
  void set_allocated_meas_info(::protocol::flex_measurement_info* meas_info);
  private:
  const ::protocol::flex_measurement_info& _internal_meas_info() const;
  ::protocol::flex_measurement_info* _internal_mutable_meas_info();
  public:
  void unsafe_arena_set_allocated_meas_info(
      ::protocol::flex_measurement_info* meas_info);
  ::protocol::flex_measurement_info* unsafe_arena_release_meas_info();

  // @@protoc_insertion_point(class_scope:protocol.flex_rrc_triggering)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rrc_trigger_;
  ::protocol::flex_header* header_;
  ::protocol::flex_measurement_info* meas_info_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_ho_command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ho_command) */ {
 public:
  inline flex_ho_command() : flex_ho_command(nullptr) {}
  virtual ~flex_ho_command();

  flex_ho_command(const flex_ho_command& from);
  flex_ho_command(flex_ho_command&& from) noexcept
    : flex_ho_command() {
    *this = ::std::move(from);
  }

  inline flex_ho_command& operator=(const flex_ho_command& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_ho_command& operator=(flex_ho_command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_ho_command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_ho_command* internal_default_instance() {
    return reinterpret_cast<const flex_ho_command*>(
               &_flex_ho_command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(flex_ho_command& a, flex_ho_command& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_ho_command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_ho_command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_ho_command* New() const final {
    return CreateMaybeMessage<flex_ho_command>(nullptr);
  }

  flex_ho_command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_ho_command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_ho_command& from);
  void MergeFrom(const flex_ho_command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_ho_command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_ho_command";
  }
  protected:
  explicit flex_ho_command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRntiFieldNumber = 2,
    kTargetPhyCellIdFieldNumber = 3,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional uint32 rnti = 2;
  bool has_rnti() const;
  private:
  bool _internal_has_rnti() const;
  public:
  void clear_rnti();
  ::PROTOBUF_NAMESPACE_ID::uint32 rnti() const;
  void set_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_rnti() const;
  void _internal_set_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 target_phy_cell_id = 3;
  bool has_target_phy_cell_id() const;
  private:
  bool _internal_has_target_phy_cell_id() const;
  public:
  void clear_target_phy_cell_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 target_phy_cell_id() const;
  void set_target_phy_cell_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_target_phy_cell_id() const;
  void _internal_set_target_phy_cell_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_ho_command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rnti_;
  ::PROTOBUF_NAMESPACE_ID::uint32 target_phy_cell_id_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_ue_state_change PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ue_state_change) */ {
 public:
  inline flex_ue_state_change() : flex_ue_state_change(nullptr) {}
  virtual ~flex_ue_state_change();

  flex_ue_state_change(const flex_ue_state_change& from);
  flex_ue_state_change(flex_ue_state_change&& from) noexcept
    : flex_ue_state_change() {
    *this = ::std::move(from);
  }

  inline flex_ue_state_change& operator=(const flex_ue_state_change& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_ue_state_change& operator=(flex_ue_state_change&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_ue_state_change& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_ue_state_change* internal_default_instance() {
    return reinterpret_cast<const flex_ue_state_change*>(
               &_flex_ue_state_change_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(flex_ue_state_change& a, flex_ue_state_change& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_ue_state_change* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_ue_state_change* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_ue_state_change* New() const final {
    return CreateMaybeMessage<flex_ue_state_change>(nullptr);
  }

  flex_ue_state_change* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_ue_state_change>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_ue_state_change& from);
  void MergeFrom(const flex_ue_state_change& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_ue_state_change* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_ue_state_change";
  }
  protected:
  explicit flex_ue_state_change(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kConfigFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional .protocol.flex_ue_config config = 3;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::protocol::flex_ue_config& config() const;
  ::protocol::flex_ue_config* release_config();
  ::protocol::flex_ue_config* mutable_config();
  void set_allocated_config(::protocol::flex_ue_config* config);
  private:
  const ::protocol::flex_ue_config& _internal_config() const;
  ::protocol::flex_ue_config* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::protocol::flex_ue_config* config);
  ::protocol::flex_ue_config* unsafe_arena_release_config();

  // optional uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_ue_state_change)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  ::protocol::flex_ue_config* config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_control_delegation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_control_delegation) */ {
 public:
  inline flex_control_delegation() : flex_control_delegation(nullptr) {}
  virtual ~flex_control_delegation();

  flex_control_delegation(const flex_control_delegation& from);
  flex_control_delegation(flex_control_delegation&& from) noexcept
    : flex_control_delegation() {
    *this = ::std::move(from);
  }

  inline flex_control_delegation& operator=(const flex_control_delegation& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_control_delegation& operator=(flex_control_delegation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_control_delegation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_control_delegation* internal_default_instance() {
    return reinterpret_cast<const flex_control_delegation*>(
               &_flex_control_delegation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(flex_control_delegation& a, flex_control_delegation& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_control_delegation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_control_delegation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_control_delegation* New() const final {
    return CreateMaybeMessage<flex_control_delegation>(nullptr);
  }

  flex_control_delegation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_control_delegation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_control_delegation& from);
  void MergeFrom(const flex_control_delegation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_control_delegation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_control_delegation";
  }
  protected:
  explicit flex_control_delegation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kNameFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kDelegationTypeFieldNumber = 2,
  };
  // optional bytes payload = 3;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // optional uint32 delegation_type = 2;
  bool has_delegation_type() const;
  private:
  bool _internal_has_delegation_type() const;
  public:
  void clear_delegation_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 delegation_type() const;
  void set_delegation_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_delegation_type() const;
  void _internal_set_delegation_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.flex_control_delegation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::protocol::flex_header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 delegation_type_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_agent_reconfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_agent_reconfiguration) */ {
 public:
  inline flex_agent_reconfiguration() : flex_agent_reconfiguration(nullptr) {}
  virtual ~flex_agent_reconfiguration();

  flex_agent_reconfiguration(const flex_agent_reconfiguration& from);
  flex_agent_reconfiguration(flex_agent_reconfiguration&& from) noexcept
    : flex_agent_reconfiguration() {
    *this = ::std::move(from);
  }

  inline flex_agent_reconfiguration& operator=(const flex_agent_reconfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_agent_reconfiguration& operator=(flex_agent_reconfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_agent_reconfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_agent_reconfiguration* internal_default_instance() {
    return reinterpret_cast<const flex_agent_reconfiguration*>(
               &_flex_agent_reconfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(flex_agent_reconfiguration& a, flex_agent_reconfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_agent_reconfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_agent_reconfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_agent_reconfiguration* New() const final {
    return CreateMaybeMessage<flex_agent_reconfiguration>(nullptr);
  }

  flex_agent_reconfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_agent_reconfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_agent_reconfiguration& from);
  void MergeFrom(const flex_agent_reconfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_agent_reconfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_agent_reconfiguration";
  }
  protected:
  explicit flex_agent_reconfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // optional string policy = 2;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  void set_policy(const std::string& value);
  void set_policy(std::string&& value);
  void set_policy(const char* value);
  void set_policy(const char* value, size_t size);
  std::string* mutable_policy();
  std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_agent_reconfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_echo_request_latency PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_request_latency) */ {
 public:
  inline flex_echo_request_latency() : flex_echo_request_latency(nullptr) {}
  virtual ~flex_echo_request_latency();

  flex_echo_request_latency(const flex_echo_request_latency& from);
  flex_echo_request_latency(flex_echo_request_latency&& from) noexcept
    : flex_echo_request_latency() {
    *this = ::std::move(from);
  }

  inline flex_echo_request_latency& operator=(const flex_echo_request_latency& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_echo_request_latency& operator=(flex_echo_request_latency&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_echo_request_latency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_echo_request_latency* internal_default_instance() {
    return reinterpret_cast<const flex_echo_request_latency*>(
               &_flex_echo_request_latency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(flex_echo_request_latency& a, flex_echo_request_latency& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_echo_request_latency* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_echo_request_latency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_echo_request_latency* New() const final {
    return CreateMaybeMessage<flex_echo_request_latency>(nullptr);
  }

  flex_echo_request_latency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_echo_request_latency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_echo_request_latency& from);
  void MergeFrom(const flex_echo_request_latency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_echo_request_latency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_echo_request_latency";
  }
  protected:
  explicit flex_echo_request_latency(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kLatencyFieldNumber = 100;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::protocol::flex_echo_request,
      ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< ::PROTOBUF_NAMESPACE_ID::uint32 >, 13, false >
    latency;
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_request_latency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_echo_reply_latency PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_reply_latency) */ {
 public:
  inline flex_echo_reply_latency() : flex_echo_reply_latency(nullptr) {}
  virtual ~flex_echo_reply_latency();

  flex_echo_reply_latency(const flex_echo_reply_latency& from);
  flex_echo_reply_latency(flex_echo_reply_latency&& from) noexcept
    : flex_echo_reply_latency() {
    *this = ::std::move(from);
  }

  inline flex_echo_reply_latency& operator=(const flex_echo_reply_latency& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_echo_reply_latency& operator=(flex_echo_reply_latency&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_echo_reply_latency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_echo_reply_latency* internal_default_instance() {
    return reinterpret_cast<const flex_echo_reply_latency*>(
               &_flex_echo_reply_latency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(flex_echo_reply_latency& a, flex_echo_reply_latency& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_echo_reply_latency* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_echo_reply_latency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_echo_reply_latency* New() const final {
    return CreateMaybeMessage<flex_echo_reply_latency>(nullptr);
  }

  flex_echo_reply_latency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_echo_reply_latency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_echo_reply_latency& from);
  void MergeFrom(const flex_echo_reply_latency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_echo_reply_latency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_echo_reply_latency";
  }
  protected:
  explicit flex_echo_reply_latency(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kLatencyFieldNumber = 100;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::protocol::flex_echo_reply,
      ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< ::PROTOBUF_NAMESPACE_ID::uint32 >, 13, false >
    latency;
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_reply_latency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexran_2eproto;
};
// -------------------------------------------------------------------

class flex_disconnect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.flex_disconnect) */ {
 public:
  inline flex_disconnect() : flex_disconnect(nullptr) {}
  virtual ~flex_disconnect();

  flex_disconnect(const flex_disconnect& from);
  flex_disconnect(flex_disconnect&& from) noexcept
    : flex_disconnect() {
    *this = ::std::move(from);
  }

  inline flex_disconnect& operator=(const flex_disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline flex_disconnect& operator=(flex_disconnect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const flex_disconnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const flex_disconnect* internal_default_instance() {
    return reinterpret_cast<const flex_disconnect*>(
               &_flex_disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(flex_disconnect& a, flex_disconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(flex_disconnect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(flex_disconnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline flex_disconnect* New() const final {
    return CreateMaybeMessage<flex_disconnect>(nullptr);
  }

  flex_disconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<flex_disconnect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const flex_disconnect& from);
  void MergeFrom(const flex_disconnect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(flex_disconnect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.flex_disconnect";
  }
  protected:
  explicit flex_disconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_flexran_2eproto);
    return ::descriptor_table_flexran_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* release_header();
  ::protocol::flex_header* mutable_header();
  void set_allocated_header(::protocol::flex_header* header);
  private:
  const ::protocol::flex_header& _internal_header() const;
  ::protocol::flex_header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::protocol::flex_header* header);
  ::protocol::flex_header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:protocol.flex_disconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::protocol::flex_header* header_;
  friend struct ::TableStruct_flexran_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// flexran_message

// optional .protocol.flexran_direction msg_dir = 100;
inline bool flexran_message::_internal_has_msg_dir() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool flexran_message::has_msg_dir() const {
  return _internal_has_msg_dir();
}
inline void flexran_message::clear_msg_dir() {
  msg_dir_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::protocol::flexran_direction flexran_message::_internal_msg_dir() const {
  return static_cast< ::protocol::flexran_direction >(msg_dir_);
}
inline ::protocol::flexran_direction flexran_message::msg_dir() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.msg_dir)
  return _internal_msg_dir();
}
inline void flexran_message::_internal_set_msg_dir(::protocol::flexran_direction value) {
  assert(::protocol::flexran_direction_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  msg_dir_ = value;
}
inline void flexran_message::set_msg_dir(::protocol::flexran_direction value) {
  _internal_set_msg_dir(value);
  // @@protoc_insertion_point(field_set:protocol.flexran_message.msg_dir)
}

// .protocol.flex_hello hello_msg = 1;
inline bool flexran_message::_internal_has_hello_msg() const {
  return msg_case() == kHelloMsg;
}
inline bool flexran_message::has_hello_msg() const {
  return _internal_has_hello_msg();
}
inline void flexran_message::set_has_hello_msg() {
  _oneof_case_[0] = kHelloMsg;
}
inline void flexran_message::clear_hello_msg() {
  if (_internal_has_hello_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.hello_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_hello* flexran_message::release_hello_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.hello_msg)
  if (_internal_has_hello_msg()) {
    clear_has_msg();
      ::protocol::flex_hello* temp = msg_.hello_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.hello_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_hello& flexran_message::_internal_hello_msg() const {
  return _internal_has_hello_msg()
      ? *msg_.hello_msg_
      : *reinterpret_cast< ::protocol::flex_hello*>(&::protocol::_flex_hello_default_instance_);
}
inline const ::protocol::flex_hello& flexran_message::hello_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.hello_msg)
  return _internal_hello_msg();
}
inline ::protocol::flex_hello* flexran_message::unsafe_arena_release_hello_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.hello_msg)
  if (_internal_has_hello_msg()) {
    clear_has_msg();
    ::protocol::flex_hello* temp = msg_.hello_msg_;
    msg_.hello_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_hello_msg(::protocol::flex_hello* hello_msg) {
  clear_msg();
  if (hello_msg) {
    set_has_hello_msg();
    msg_.hello_msg_ = hello_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.hello_msg)
}
inline ::protocol::flex_hello* flexran_message::_internal_mutable_hello_msg() {
  if (!_internal_has_hello_msg()) {
    clear_msg();
    set_has_hello_msg();
    msg_.hello_msg_ = CreateMaybeMessage< ::protocol::flex_hello >(GetArena());
  }
  return msg_.hello_msg_;
}
inline ::protocol::flex_hello* flexran_message::mutable_hello_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.hello_msg)
  return _internal_mutable_hello_msg();
}

// .protocol.flex_echo_request echo_request_msg = 2;
inline bool flexran_message::_internal_has_echo_request_msg() const {
  return msg_case() == kEchoRequestMsg;
}
inline bool flexran_message::has_echo_request_msg() const {
  return _internal_has_echo_request_msg();
}
inline void flexran_message::set_has_echo_request_msg() {
  _oneof_case_[0] = kEchoRequestMsg;
}
inline void flexran_message::clear_echo_request_msg() {
  if (_internal_has_echo_request_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.echo_request_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_echo_request* flexran_message::release_echo_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.echo_request_msg)
  if (_internal_has_echo_request_msg()) {
    clear_has_msg();
      ::protocol::flex_echo_request* temp = msg_.echo_request_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.echo_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_echo_request& flexran_message::_internal_echo_request_msg() const {
  return _internal_has_echo_request_msg()
      ? *msg_.echo_request_msg_
      : *reinterpret_cast< ::protocol::flex_echo_request*>(&::protocol::_flex_echo_request_default_instance_);
}
inline const ::protocol::flex_echo_request& flexran_message::echo_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.echo_request_msg)
  return _internal_echo_request_msg();
}
inline ::protocol::flex_echo_request* flexran_message::unsafe_arena_release_echo_request_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.echo_request_msg)
  if (_internal_has_echo_request_msg()) {
    clear_has_msg();
    ::protocol::flex_echo_request* temp = msg_.echo_request_msg_;
    msg_.echo_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_echo_request_msg(::protocol::flex_echo_request* echo_request_msg) {
  clear_msg();
  if (echo_request_msg) {
    set_has_echo_request_msg();
    msg_.echo_request_msg_ = echo_request_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.echo_request_msg)
}
inline ::protocol::flex_echo_request* flexran_message::_internal_mutable_echo_request_msg() {
  if (!_internal_has_echo_request_msg()) {
    clear_msg();
    set_has_echo_request_msg();
    msg_.echo_request_msg_ = CreateMaybeMessage< ::protocol::flex_echo_request >(GetArena());
  }
  return msg_.echo_request_msg_;
}
inline ::protocol::flex_echo_request* flexran_message::mutable_echo_request_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.echo_request_msg)
  return _internal_mutable_echo_request_msg();
}

// .protocol.flex_echo_reply echo_reply_msg = 3;
inline bool flexran_message::_internal_has_echo_reply_msg() const {
  return msg_case() == kEchoReplyMsg;
}
inline bool flexran_message::has_echo_reply_msg() const {
  return _internal_has_echo_reply_msg();
}
inline void flexran_message::set_has_echo_reply_msg() {
  _oneof_case_[0] = kEchoReplyMsg;
}
inline void flexran_message::clear_echo_reply_msg() {
  if (_internal_has_echo_reply_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.echo_reply_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_echo_reply* flexran_message::release_echo_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.echo_reply_msg)
  if (_internal_has_echo_reply_msg()) {
    clear_has_msg();
      ::protocol::flex_echo_reply* temp = msg_.echo_reply_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.echo_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_echo_reply& flexran_message::_internal_echo_reply_msg() const {
  return _internal_has_echo_reply_msg()
      ? *msg_.echo_reply_msg_
      : *reinterpret_cast< ::protocol::flex_echo_reply*>(&::protocol::_flex_echo_reply_default_instance_);
}
inline const ::protocol::flex_echo_reply& flexran_message::echo_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.echo_reply_msg)
  return _internal_echo_reply_msg();
}
inline ::protocol::flex_echo_reply* flexran_message::unsafe_arena_release_echo_reply_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.echo_reply_msg)
  if (_internal_has_echo_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_echo_reply* temp = msg_.echo_reply_msg_;
    msg_.echo_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_echo_reply_msg(::protocol::flex_echo_reply* echo_reply_msg) {
  clear_msg();
  if (echo_reply_msg) {
    set_has_echo_reply_msg();
    msg_.echo_reply_msg_ = echo_reply_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.echo_reply_msg)
}
inline ::protocol::flex_echo_reply* flexran_message::_internal_mutable_echo_reply_msg() {
  if (!_internal_has_echo_reply_msg()) {
    clear_msg();
    set_has_echo_reply_msg();
    msg_.echo_reply_msg_ = CreateMaybeMessage< ::protocol::flex_echo_reply >(GetArena());
  }
  return msg_.echo_reply_msg_;
}
inline ::protocol::flex_echo_reply* flexran_message::mutable_echo_reply_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.echo_reply_msg)
  return _internal_mutable_echo_reply_msg();
}

// .protocol.flex_stats_request stats_request_msg = 4;
inline bool flexran_message::_internal_has_stats_request_msg() const {
  return msg_case() == kStatsRequestMsg;
}
inline bool flexran_message::has_stats_request_msg() const {
  return _internal_has_stats_request_msg();
}
inline void flexran_message::set_has_stats_request_msg() {
  _oneof_case_[0] = kStatsRequestMsg;
}
inline void flexran_message::clear_stats_request_msg() {
  if (_internal_has_stats_request_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.stats_request_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_stats_request* flexran_message::release_stats_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.stats_request_msg)
  if (_internal_has_stats_request_msg()) {
    clear_has_msg();
      ::protocol::flex_stats_request* temp = msg_.stats_request_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.stats_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_stats_request& flexran_message::_internal_stats_request_msg() const {
  return _internal_has_stats_request_msg()
      ? *msg_.stats_request_msg_
      : *reinterpret_cast< ::protocol::flex_stats_request*>(&::protocol::_flex_stats_request_default_instance_);
}
inline const ::protocol::flex_stats_request& flexran_message::stats_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.stats_request_msg)
  return _internal_stats_request_msg();
}
inline ::protocol::flex_stats_request* flexran_message::unsafe_arena_release_stats_request_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.stats_request_msg)
  if (_internal_has_stats_request_msg()) {
    clear_has_msg();
    ::protocol::flex_stats_request* temp = msg_.stats_request_msg_;
    msg_.stats_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_stats_request_msg(::protocol::flex_stats_request* stats_request_msg) {
  clear_msg();
  if (stats_request_msg) {
    set_has_stats_request_msg();
    msg_.stats_request_msg_ = stats_request_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.stats_request_msg)
}
inline ::protocol::flex_stats_request* flexran_message::_internal_mutable_stats_request_msg() {
  if (!_internal_has_stats_request_msg()) {
    clear_msg();
    set_has_stats_request_msg();
    msg_.stats_request_msg_ = CreateMaybeMessage< ::protocol::flex_stats_request >(GetArena());
  }
  return msg_.stats_request_msg_;
}
inline ::protocol::flex_stats_request* flexran_message::mutable_stats_request_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.stats_request_msg)
  return _internal_mutable_stats_request_msg();
}

// .protocol.flex_stats_reply stats_reply_msg = 5;
inline bool flexran_message::_internal_has_stats_reply_msg() const {
  return msg_case() == kStatsReplyMsg;
}
inline bool flexran_message::has_stats_reply_msg() const {
  return _internal_has_stats_reply_msg();
}
inline void flexran_message::set_has_stats_reply_msg() {
  _oneof_case_[0] = kStatsReplyMsg;
}
inline void flexran_message::clear_stats_reply_msg() {
  if (_internal_has_stats_reply_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.stats_reply_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_stats_reply* flexran_message::release_stats_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.stats_reply_msg)
  if (_internal_has_stats_reply_msg()) {
    clear_has_msg();
      ::protocol::flex_stats_reply* temp = msg_.stats_reply_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.stats_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_stats_reply& flexran_message::_internal_stats_reply_msg() const {
  return _internal_has_stats_reply_msg()
      ? *msg_.stats_reply_msg_
      : *reinterpret_cast< ::protocol::flex_stats_reply*>(&::protocol::_flex_stats_reply_default_instance_);
}
inline const ::protocol::flex_stats_reply& flexran_message::stats_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.stats_reply_msg)
  return _internal_stats_reply_msg();
}
inline ::protocol::flex_stats_reply* flexran_message::unsafe_arena_release_stats_reply_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.stats_reply_msg)
  if (_internal_has_stats_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_stats_reply* temp = msg_.stats_reply_msg_;
    msg_.stats_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_stats_reply_msg(::protocol::flex_stats_reply* stats_reply_msg) {
  clear_msg();
  if (stats_reply_msg) {
    set_has_stats_reply_msg();
    msg_.stats_reply_msg_ = stats_reply_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.stats_reply_msg)
}
inline ::protocol::flex_stats_reply* flexran_message::_internal_mutable_stats_reply_msg() {
  if (!_internal_has_stats_reply_msg()) {
    clear_msg();
    set_has_stats_reply_msg();
    msg_.stats_reply_msg_ = CreateMaybeMessage< ::protocol::flex_stats_reply >(GetArena());
  }
  return msg_.stats_reply_msg_;
}
inline ::protocol::flex_stats_reply* flexran_message::mutable_stats_reply_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.stats_reply_msg)
  return _internal_mutable_stats_reply_msg();
}

// .protocol.flex_sf_trigger sf_trigger_msg = 6;
inline bool flexran_message::_internal_has_sf_trigger_msg() const {
  return msg_case() == kSfTriggerMsg;
}
inline bool flexran_message::has_sf_trigger_msg() const {
  return _internal_has_sf_trigger_msg();
}
inline void flexran_message::set_has_sf_trigger_msg() {
  _oneof_case_[0] = kSfTriggerMsg;
}
inline void flexran_message::clear_sf_trigger_msg() {
  if (_internal_has_sf_trigger_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.sf_trigger_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_sf_trigger* flexran_message::release_sf_trigger_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.sf_trigger_msg)
  if (_internal_has_sf_trigger_msg()) {
    clear_has_msg();
      ::protocol::flex_sf_trigger* temp = msg_.sf_trigger_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.sf_trigger_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_sf_trigger& flexran_message::_internal_sf_trigger_msg() const {
  return _internal_has_sf_trigger_msg()
      ? *msg_.sf_trigger_msg_
      : *reinterpret_cast< ::protocol::flex_sf_trigger*>(&::protocol::_flex_sf_trigger_default_instance_);
}
inline const ::protocol::flex_sf_trigger& flexran_message::sf_trigger_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.sf_trigger_msg)
  return _internal_sf_trigger_msg();
}
inline ::protocol::flex_sf_trigger* flexran_message::unsafe_arena_release_sf_trigger_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.sf_trigger_msg)
  if (_internal_has_sf_trigger_msg()) {
    clear_has_msg();
    ::protocol::flex_sf_trigger* temp = msg_.sf_trigger_msg_;
    msg_.sf_trigger_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_sf_trigger_msg(::protocol::flex_sf_trigger* sf_trigger_msg) {
  clear_msg();
  if (sf_trigger_msg) {
    set_has_sf_trigger_msg();
    msg_.sf_trigger_msg_ = sf_trigger_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.sf_trigger_msg)
}
inline ::protocol::flex_sf_trigger* flexran_message::_internal_mutable_sf_trigger_msg() {
  if (!_internal_has_sf_trigger_msg()) {
    clear_msg();
    set_has_sf_trigger_msg();
    msg_.sf_trigger_msg_ = CreateMaybeMessage< ::protocol::flex_sf_trigger >(GetArena());
  }
  return msg_.sf_trigger_msg_;
}
inline ::protocol::flex_sf_trigger* flexran_message::mutable_sf_trigger_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.sf_trigger_msg)
  return _internal_mutable_sf_trigger_msg();
}

// .protocol.flex_ul_sr_info ul_sr_info_msg = 7;
inline bool flexran_message::_internal_has_ul_sr_info_msg() const {
  return msg_case() == kUlSrInfoMsg;
}
inline bool flexran_message::has_ul_sr_info_msg() const {
  return _internal_has_ul_sr_info_msg();
}
inline void flexran_message::set_has_ul_sr_info_msg() {
  _oneof_case_[0] = kUlSrInfoMsg;
}
inline void flexran_message::clear_ul_sr_info_msg() {
  if (_internal_has_ul_sr_info_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.ul_sr_info_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_ul_sr_info* flexran_message::release_ul_sr_info_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ul_sr_info_msg)
  if (_internal_has_ul_sr_info_msg()) {
    clear_has_msg();
      ::protocol::flex_ul_sr_info* temp = msg_.ul_sr_info_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ul_sr_info_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_ul_sr_info& flexran_message::_internal_ul_sr_info_msg() const {
  return _internal_has_ul_sr_info_msg()
      ? *msg_.ul_sr_info_msg_
      : *reinterpret_cast< ::protocol::flex_ul_sr_info*>(&::protocol::_flex_ul_sr_info_default_instance_);
}
inline const ::protocol::flex_ul_sr_info& flexran_message::ul_sr_info_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ul_sr_info_msg)
  return _internal_ul_sr_info_msg();
}
inline ::protocol::flex_ul_sr_info* flexran_message::unsafe_arena_release_ul_sr_info_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.ul_sr_info_msg)
  if (_internal_has_ul_sr_info_msg()) {
    clear_has_msg();
    ::protocol::flex_ul_sr_info* temp = msg_.ul_sr_info_msg_;
    msg_.ul_sr_info_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_ul_sr_info_msg(::protocol::flex_ul_sr_info* ul_sr_info_msg) {
  clear_msg();
  if (ul_sr_info_msg) {
    set_has_ul_sr_info_msg();
    msg_.ul_sr_info_msg_ = ul_sr_info_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.ul_sr_info_msg)
}
inline ::protocol::flex_ul_sr_info* flexran_message::_internal_mutable_ul_sr_info_msg() {
  if (!_internal_has_ul_sr_info_msg()) {
    clear_msg();
    set_has_ul_sr_info_msg();
    msg_.ul_sr_info_msg_ = CreateMaybeMessage< ::protocol::flex_ul_sr_info >(GetArena());
  }
  return msg_.ul_sr_info_msg_;
}
inline ::protocol::flex_ul_sr_info* flexran_message::mutable_ul_sr_info_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ul_sr_info_msg)
  return _internal_mutable_ul_sr_info_msg();
}

// .protocol.flex_enb_config_request enb_config_request_msg = 8;
inline bool flexran_message::_internal_has_enb_config_request_msg() const {
  return msg_case() == kEnbConfigRequestMsg;
}
inline bool flexran_message::has_enb_config_request_msg() const {
  return _internal_has_enb_config_request_msg();
}
inline void flexran_message::set_has_enb_config_request_msg() {
  _oneof_case_[0] = kEnbConfigRequestMsg;
}
inline void flexran_message::clear_enb_config_request_msg() {
  if (_internal_has_enb_config_request_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.enb_config_request_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_enb_config_request* flexran_message::release_enb_config_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.enb_config_request_msg)
  if (_internal_has_enb_config_request_msg()) {
    clear_has_msg();
      ::protocol::flex_enb_config_request* temp = msg_.enb_config_request_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.enb_config_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_enb_config_request& flexran_message::_internal_enb_config_request_msg() const {
  return _internal_has_enb_config_request_msg()
      ? *msg_.enb_config_request_msg_
      : *reinterpret_cast< ::protocol::flex_enb_config_request*>(&::protocol::_flex_enb_config_request_default_instance_);
}
inline const ::protocol::flex_enb_config_request& flexran_message::enb_config_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.enb_config_request_msg)
  return _internal_enb_config_request_msg();
}
inline ::protocol::flex_enb_config_request* flexran_message::unsafe_arena_release_enb_config_request_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.enb_config_request_msg)
  if (_internal_has_enb_config_request_msg()) {
    clear_has_msg();
    ::protocol::flex_enb_config_request* temp = msg_.enb_config_request_msg_;
    msg_.enb_config_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_enb_config_request_msg(::protocol::flex_enb_config_request* enb_config_request_msg) {
  clear_msg();
  if (enb_config_request_msg) {
    set_has_enb_config_request_msg();
    msg_.enb_config_request_msg_ = enb_config_request_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.enb_config_request_msg)
}
inline ::protocol::flex_enb_config_request* flexran_message::_internal_mutable_enb_config_request_msg() {
  if (!_internal_has_enb_config_request_msg()) {
    clear_msg();
    set_has_enb_config_request_msg();
    msg_.enb_config_request_msg_ = CreateMaybeMessage< ::protocol::flex_enb_config_request >(GetArena());
  }
  return msg_.enb_config_request_msg_;
}
inline ::protocol::flex_enb_config_request* flexran_message::mutable_enb_config_request_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.enb_config_request_msg)
  return _internal_mutable_enb_config_request_msg();
}

// .protocol.flex_enb_config_reply enb_config_reply_msg = 9;
inline bool flexran_message::_internal_has_enb_config_reply_msg() const {
  return msg_case() == kEnbConfigReplyMsg;
}
inline bool flexran_message::has_enb_config_reply_msg() const {
  return _internal_has_enb_config_reply_msg();
}
inline void flexran_message::set_has_enb_config_reply_msg() {
  _oneof_case_[0] = kEnbConfigReplyMsg;
}
inline void flexran_message::clear_enb_config_reply_msg() {
  if (_internal_has_enb_config_reply_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.enb_config_reply_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_enb_config_reply* flexran_message::release_enb_config_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.enb_config_reply_msg)
  if (_internal_has_enb_config_reply_msg()) {
    clear_has_msg();
      ::protocol::flex_enb_config_reply* temp = msg_.enb_config_reply_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.enb_config_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_enb_config_reply& flexran_message::_internal_enb_config_reply_msg() const {
  return _internal_has_enb_config_reply_msg()
      ? *msg_.enb_config_reply_msg_
      : *reinterpret_cast< ::protocol::flex_enb_config_reply*>(&::protocol::_flex_enb_config_reply_default_instance_);
}
inline const ::protocol::flex_enb_config_reply& flexran_message::enb_config_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.enb_config_reply_msg)
  return _internal_enb_config_reply_msg();
}
inline ::protocol::flex_enb_config_reply* flexran_message::unsafe_arena_release_enb_config_reply_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.enb_config_reply_msg)
  if (_internal_has_enb_config_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_enb_config_reply* temp = msg_.enb_config_reply_msg_;
    msg_.enb_config_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_enb_config_reply_msg(::protocol::flex_enb_config_reply* enb_config_reply_msg) {
  clear_msg();
  if (enb_config_reply_msg) {
    set_has_enb_config_reply_msg();
    msg_.enb_config_reply_msg_ = enb_config_reply_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.enb_config_reply_msg)
}
inline ::protocol::flex_enb_config_reply* flexran_message::_internal_mutable_enb_config_reply_msg() {
  if (!_internal_has_enb_config_reply_msg()) {
    clear_msg();
    set_has_enb_config_reply_msg();
    msg_.enb_config_reply_msg_ = CreateMaybeMessage< ::protocol::flex_enb_config_reply >(GetArena());
  }
  return msg_.enb_config_reply_msg_;
}
inline ::protocol::flex_enb_config_reply* flexran_message::mutable_enb_config_reply_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.enb_config_reply_msg)
  return _internal_mutable_enb_config_reply_msg();
}

// .protocol.flex_ue_config_request ue_config_request_msg = 10;
inline bool flexran_message::_internal_has_ue_config_request_msg() const {
  return msg_case() == kUeConfigRequestMsg;
}
inline bool flexran_message::has_ue_config_request_msg() const {
  return _internal_has_ue_config_request_msg();
}
inline void flexran_message::set_has_ue_config_request_msg() {
  _oneof_case_[0] = kUeConfigRequestMsg;
}
inline void flexran_message::clear_ue_config_request_msg() {
  if (_internal_has_ue_config_request_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.ue_config_request_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_ue_config_request* flexran_message::release_ue_config_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ue_config_request_msg)
  if (_internal_has_ue_config_request_msg()) {
    clear_has_msg();
      ::protocol::flex_ue_config_request* temp = msg_.ue_config_request_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ue_config_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_ue_config_request& flexran_message::_internal_ue_config_request_msg() const {
  return _internal_has_ue_config_request_msg()
      ? *msg_.ue_config_request_msg_
      : *reinterpret_cast< ::protocol::flex_ue_config_request*>(&::protocol::_flex_ue_config_request_default_instance_);
}
inline const ::protocol::flex_ue_config_request& flexran_message::ue_config_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ue_config_request_msg)
  return _internal_ue_config_request_msg();
}
inline ::protocol::flex_ue_config_request* flexran_message::unsafe_arena_release_ue_config_request_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.ue_config_request_msg)
  if (_internal_has_ue_config_request_msg()) {
    clear_has_msg();
    ::protocol::flex_ue_config_request* temp = msg_.ue_config_request_msg_;
    msg_.ue_config_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_ue_config_request_msg(::protocol::flex_ue_config_request* ue_config_request_msg) {
  clear_msg();
  if (ue_config_request_msg) {
    set_has_ue_config_request_msg();
    msg_.ue_config_request_msg_ = ue_config_request_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.ue_config_request_msg)
}
inline ::protocol::flex_ue_config_request* flexran_message::_internal_mutable_ue_config_request_msg() {
  if (!_internal_has_ue_config_request_msg()) {
    clear_msg();
    set_has_ue_config_request_msg();
    msg_.ue_config_request_msg_ = CreateMaybeMessage< ::protocol::flex_ue_config_request >(GetArena());
  }
  return msg_.ue_config_request_msg_;
}
inline ::protocol::flex_ue_config_request* flexran_message::mutable_ue_config_request_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ue_config_request_msg)
  return _internal_mutable_ue_config_request_msg();
}

// .protocol.flex_ue_config_reply ue_config_reply_msg = 11;
inline bool flexran_message::_internal_has_ue_config_reply_msg() const {
  return msg_case() == kUeConfigReplyMsg;
}
inline bool flexran_message::has_ue_config_reply_msg() const {
  return _internal_has_ue_config_reply_msg();
}
inline void flexran_message::set_has_ue_config_reply_msg() {
  _oneof_case_[0] = kUeConfigReplyMsg;
}
inline void flexran_message::clear_ue_config_reply_msg() {
  if (_internal_has_ue_config_reply_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.ue_config_reply_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_ue_config_reply* flexran_message::release_ue_config_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ue_config_reply_msg)
  if (_internal_has_ue_config_reply_msg()) {
    clear_has_msg();
      ::protocol::flex_ue_config_reply* temp = msg_.ue_config_reply_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ue_config_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_ue_config_reply& flexran_message::_internal_ue_config_reply_msg() const {
  return _internal_has_ue_config_reply_msg()
      ? *msg_.ue_config_reply_msg_
      : *reinterpret_cast< ::protocol::flex_ue_config_reply*>(&::protocol::_flex_ue_config_reply_default_instance_);
}
inline const ::protocol::flex_ue_config_reply& flexran_message::ue_config_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ue_config_reply_msg)
  return _internal_ue_config_reply_msg();
}
inline ::protocol::flex_ue_config_reply* flexran_message::unsafe_arena_release_ue_config_reply_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.ue_config_reply_msg)
  if (_internal_has_ue_config_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_ue_config_reply* temp = msg_.ue_config_reply_msg_;
    msg_.ue_config_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_ue_config_reply_msg(::protocol::flex_ue_config_reply* ue_config_reply_msg) {
  clear_msg();
  if (ue_config_reply_msg) {
    set_has_ue_config_reply_msg();
    msg_.ue_config_reply_msg_ = ue_config_reply_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.ue_config_reply_msg)
}
inline ::protocol::flex_ue_config_reply* flexran_message::_internal_mutable_ue_config_reply_msg() {
  if (!_internal_has_ue_config_reply_msg()) {
    clear_msg();
    set_has_ue_config_reply_msg();
    msg_.ue_config_reply_msg_ = CreateMaybeMessage< ::protocol::flex_ue_config_reply >(GetArena());
  }
  return msg_.ue_config_reply_msg_;
}
inline ::protocol::flex_ue_config_reply* flexran_message::mutable_ue_config_reply_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ue_config_reply_msg)
  return _internal_mutable_ue_config_reply_msg();
}

// .protocol.flex_lc_config_request lc_config_request_msg = 12;
inline bool flexran_message::_internal_has_lc_config_request_msg() const {
  return msg_case() == kLcConfigRequestMsg;
}
inline bool flexran_message::has_lc_config_request_msg() const {
  return _internal_has_lc_config_request_msg();
}
inline void flexran_message::set_has_lc_config_request_msg() {
  _oneof_case_[0] = kLcConfigRequestMsg;
}
inline void flexran_message::clear_lc_config_request_msg() {
  if (_internal_has_lc_config_request_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.lc_config_request_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_lc_config_request* flexran_message::release_lc_config_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.lc_config_request_msg)
  if (_internal_has_lc_config_request_msg()) {
    clear_has_msg();
      ::protocol::flex_lc_config_request* temp = msg_.lc_config_request_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.lc_config_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_lc_config_request& flexran_message::_internal_lc_config_request_msg() const {
  return _internal_has_lc_config_request_msg()
      ? *msg_.lc_config_request_msg_
      : *reinterpret_cast< ::protocol::flex_lc_config_request*>(&::protocol::_flex_lc_config_request_default_instance_);
}
inline const ::protocol::flex_lc_config_request& flexran_message::lc_config_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.lc_config_request_msg)
  return _internal_lc_config_request_msg();
}
inline ::protocol::flex_lc_config_request* flexran_message::unsafe_arena_release_lc_config_request_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.lc_config_request_msg)
  if (_internal_has_lc_config_request_msg()) {
    clear_has_msg();
    ::protocol::flex_lc_config_request* temp = msg_.lc_config_request_msg_;
    msg_.lc_config_request_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_lc_config_request_msg(::protocol::flex_lc_config_request* lc_config_request_msg) {
  clear_msg();
  if (lc_config_request_msg) {
    set_has_lc_config_request_msg();
    msg_.lc_config_request_msg_ = lc_config_request_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.lc_config_request_msg)
}
inline ::protocol::flex_lc_config_request* flexran_message::_internal_mutable_lc_config_request_msg() {
  if (!_internal_has_lc_config_request_msg()) {
    clear_msg();
    set_has_lc_config_request_msg();
    msg_.lc_config_request_msg_ = CreateMaybeMessage< ::protocol::flex_lc_config_request >(GetArena());
  }
  return msg_.lc_config_request_msg_;
}
inline ::protocol::flex_lc_config_request* flexran_message::mutable_lc_config_request_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.lc_config_request_msg)
  return _internal_mutable_lc_config_request_msg();
}

// .protocol.flex_lc_config_reply lc_config_reply_msg = 13;
inline bool flexran_message::_internal_has_lc_config_reply_msg() const {
  return msg_case() == kLcConfigReplyMsg;
}
inline bool flexran_message::has_lc_config_reply_msg() const {
  return _internal_has_lc_config_reply_msg();
}
inline void flexran_message::set_has_lc_config_reply_msg() {
  _oneof_case_[0] = kLcConfigReplyMsg;
}
inline void flexran_message::clear_lc_config_reply_msg() {
  if (_internal_has_lc_config_reply_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.lc_config_reply_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_lc_config_reply* flexran_message::release_lc_config_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.lc_config_reply_msg)
  if (_internal_has_lc_config_reply_msg()) {
    clear_has_msg();
      ::protocol::flex_lc_config_reply* temp = msg_.lc_config_reply_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.lc_config_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_lc_config_reply& flexran_message::_internal_lc_config_reply_msg() const {
  return _internal_has_lc_config_reply_msg()
      ? *msg_.lc_config_reply_msg_
      : *reinterpret_cast< ::protocol::flex_lc_config_reply*>(&::protocol::_flex_lc_config_reply_default_instance_);
}
inline const ::protocol::flex_lc_config_reply& flexran_message::lc_config_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.lc_config_reply_msg)
  return _internal_lc_config_reply_msg();
}
inline ::protocol::flex_lc_config_reply* flexran_message::unsafe_arena_release_lc_config_reply_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.lc_config_reply_msg)
  if (_internal_has_lc_config_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_lc_config_reply* temp = msg_.lc_config_reply_msg_;
    msg_.lc_config_reply_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_lc_config_reply_msg(::protocol::flex_lc_config_reply* lc_config_reply_msg) {
  clear_msg();
  if (lc_config_reply_msg) {
    set_has_lc_config_reply_msg();
    msg_.lc_config_reply_msg_ = lc_config_reply_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.lc_config_reply_msg)
}
inline ::protocol::flex_lc_config_reply* flexran_message::_internal_mutable_lc_config_reply_msg() {
  if (!_internal_has_lc_config_reply_msg()) {
    clear_msg();
    set_has_lc_config_reply_msg();
    msg_.lc_config_reply_msg_ = CreateMaybeMessage< ::protocol::flex_lc_config_reply >(GetArena());
  }
  return msg_.lc_config_reply_msg_;
}
inline ::protocol::flex_lc_config_reply* flexran_message::mutable_lc_config_reply_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.lc_config_reply_msg)
  return _internal_mutable_lc_config_reply_msg();
}

// .protocol.flex_dl_mac_config dl_mac_config_msg = 14;
inline bool flexran_message::_internal_has_dl_mac_config_msg() const {
  return msg_case() == kDlMacConfigMsg;
}
inline bool flexran_message::has_dl_mac_config_msg() const {
  return _internal_has_dl_mac_config_msg();
}
inline void flexran_message::set_has_dl_mac_config_msg() {
  _oneof_case_[0] = kDlMacConfigMsg;
}
inline void flexran_message::clear_dl_mac_config_msg() {
  if (_internal_has_dl_mac_config_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.dl_mac_config_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_dl_mac_config* flexran_message::release_dl_mac_config_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.dl_mac_config_msg)
  if (_internal_has_dl_mac_config_msg()) {
    clear_has_msg();
      ::protocol::flex_dl_mac_config* temp = msg_.dl_mac_config_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.dl_mac_config_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_dl_mac_config& flexran_message::_internal_dl_mac_config_msg() const {
  return _internal_has_dl_mac_config_msg()
      ? *msg_.dl_mac_config_msg_
      : *reinterpret_cast< ::protocol::flex_dl_mac_config*>(&::protocol::_flex_dl_mac_config_default_instance_);
}
inline const ::protocol::flex_dl_mac_config& flexran_message::dl_mac_config_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.dl_mac_config_msg)
  return _internal_dl_mac_config_msg();
}
inline ::protocol::flex_dl_mac_config* flexran_message::unsafe_arena_release_dl_mac_config_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.dl_mac_config_msg)
  if (_internal_has_dl_mac_config_msg()) {
    clear_has_msg();
    ::protocol::flex_dl_mac_config* temp = msg_.dl_mac_config_msg_;
    msg_.dl_mac_config_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_dl_mac_config_msg(::protocol::flex_dl_mac_config* dl_mac_config_msg) {
  clear_msg();
  if (dl_mac_config_msg) {
    set_has_dl_mac_config_msg();
    msg_.dl_mac_config_msg_ = dl_mac_config_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.dl_mac_config_msg)
}
inline ::protocol::flex_dl_mac_config* flexran_message::_internal_mutable_dl_mac_config_msg() {
  if (!_internal_has_dl_mac_config_msg()) {
    clear_msg();
    set_has_dl_mac_config_msg();
    msg_.dl_mac_config_msg_ = CreateMaybeMessage< ::protocol::flex_dl_mac_config >(GetArena());
  }
  return msg_.dl_mac_config_msg_;
}
inline ::protocol::flex_dl_mac_config* flexran_message::mutable_dl_mac_config_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.dl_mac_config_msg)
  return _internal_mutable_dl_mac_config_msg();
}

// .protocol.flex_ue_state_change ue_state_change_msg = 15;
inline bool flexran_message::_internal_has_ue_state_change_msg() const {
  return msg_case() == kUeStateChangeMsg;
}
inline bool flexran_message::has_ue_state_change_msg() const {
  return _internal_has_ue_state_change_msg();
}
inline void flexran_message::set_has_ue_state_change_msg() {
  _oneof_case_[0] = kUeStateChangeMsg;
}
inline void flexran_message::clear_ue_state_change_msg() {
  if (_internal_has_ue_state_change_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.ue_state_change_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_ue_state_change* flexran_message::release_ue_state_change_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ue_state_change_msg)
  if (_internal_has_ue_state_change_msg()) {
    clear_has_msg();
      ::protocol::flex_ue_state_change* temp = msg_.ue_state_change_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ue_state_change_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_ue_state_change& flexran_message::_internal_ue_state_change_msg() const {
  return _internal_has_ue_state_change_msg()
      ? *msg_.ue_state_change_msg_
      : *reinterpret_cast< ::protocol::flex_ue_state_change*>(&::protocol::_flex_ue_state_change_default_instance_);
}
inline const ::protocol::flex_ue_state_change& flexran_message::ue_state_change_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ue_state_change_msg)
  return _internal_ue_state_change_msg();
}
inline ::protocol::flex_ue_state_change* flexran_message::unsafe_arena_release_ue_state_change_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.ue_state_change_msg)
  if (_internal_has_ue_state_change_msg()) {
    clear_has_msg();
    ::protocol::flex_ue_state_change* temp = msg_.ue_state_change_msg_;
    msg_.ue_state_change_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_ue_state_change_msg(::protocol::flex_ue_state_change* ue_state_change_msg) {
  clear_msg();
  if (ue_state_change_msg) {
    set_has_ue_state_change_msg();
    msg_.ue_state_change_msg_ = ue_state_change_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.ue_state_change_msg)
}
inline ::protocol::flex_ue_state_change* flexran_message::_internal_mutable_ue_state_change_msg() {
  if (!_internal_has_ue_state_change_msg()) {
    clear_msg();
    set_has_ue_state_change_msg();
    msg_.ue_state_change_msg_ = CreateMaybeMessage< ::protocol::flex_ue_state_change >(GetArena());
  }
  return msg_.ue_state_change_msg_;
}
inline ::protocol::flex_ue_state_change* flexran_message::mutable_ue_state_change_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ue_state_change_msg)
  return _internal_mutable_ue_state_change_msg();
}

// .protocol.flex_control_delegation control_delegation_msg = 16;
inline bool flexran_message::_internal_has_control_delegation_msg() const {
  return msg_case() == kControlDelegationMsg;
}
inline bool flexran_message::has_control_delegation_msg() const {
  return _internal_has_control_delegation_msg();
}
inline void flexran_message::set_has_control_delegation_msg() {
  _oneof_case_[0] = kControlDelegationMsg;
}
inline void flexran_message::clear_control_delegation_msg() {
  if (_internal_has_control_delegation_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.control_delegation_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_control_delegation* flexran_message::release_control_delegation_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.control_delegation_msg)
  if (_internal_has_control_delegation_msg()) {
    clear_has_msg();
      ::protocol::flex_control_delegation* temp = msg_.control_delegation_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.control_delegation_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_control_delegation& flexran_message::_internal_control_delegation_msg() const {
  return _internal_has_control_delegation_msg()
      ? *msg_.control_delegation_msg_
      : *reinterpret_cast< ::protocol::flex_control_delegation*>(&::protocol::_flex_control_delegation_default_instance_);
}
inline const ::protocol::flex_control_delegation& flexran_message::control_delegation_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.control_delegation_msg)
  return _internal_control_delegation_msg();
}
inline ::protocol::flex_control_delegation* flexran_message::unsafe_arena_release_control_delegation_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.control_delegation_msg)
  if (_internal_has_control_delegation_msg()) {
    clear_has_msg();
    ::protocol::flex_control_delegation* temp = msg_.control_delegation_msg_;
    msg_.control_delegation_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_control_delegation_msg(::protocol::flex_control_delegation* control_delegation_msg) {
  clear_msg();
  if (control_delegation_msg) {
    set_has_control_delegation_msg();
    msg_.control_delegation_msg_ = control_delegation_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.control_delegation_msg)
}
inline ::protocol::flex_control_delegation* flexran_message::_internal_mutable_control_delegation_msg() {
  if (!_internal_has_control_delegation_msg()) {
    clear_msg();
    set_has_control_delegation_msg();
    msg_.control_delegation_msg_ = CreateMaybeMessage< ::protocol::flex_control_delegation >(GetArena());
  }
  return msg_.control_delegation_msg_;
}
inline ::protocol::flex_control_delegation* flexran_message::mutable_control_delegation_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.control_delegation_msg)
  return _internal_mutable_control_delegation_msg();
}

// .protocol.flex_agent_reconfiguration agent_reconfiguration_msg = 17;
inline bool flexran_message::_internal_has_agent_reconfiguration_msg() const {
  return msg_case() == kAgentReconfigurationMsg;
}
inline bool flexran_message::has_agent_reconfiguration_msg() const {
  return _internal_has_agent_reconfiguration_msg();
}
inline void flexran_message::set_has_agent_reconfiguration_msg() {
  _oneof_case_[0] = kAgentReconfigurationMsg;
}
inline void flexran_message::clear_agent_reconfiguration_msg() {
  if (_internal_has_agent_reconfiguration_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.agent_reconfiguration_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_agent_reconfiguration* flexran_message::release_agent_reconfiguration_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.agent_reconfiguration_msg)
  if (_internal_has_agent_reconfiguration_msg()) {
    clear_has_msg();
      ::protocol::flex_agent_reconfiguration* temp = msg_.agent_reconfiguration_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.agent_reconfiguration_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_agent_reconfiguration& flexran_message::_internal_agent_reconfiguration_msg() const {
  return _internal_has_agent_reconfiguration_msg()
      ? *msg_.agent_reconfiguration_msg_
      : *reinterpret_cast< ::protocol::flex_agent_reconfiguration*>(&::protocol::_flex_agent_reconfiguration_default_instance_);
}
inline const ::protocol::flex_agent_reconfiguration& flexran_message::agent_reconfiguration_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.agent_reconfiguration_msg)
  return _internal_agent_reconfiguration_msg();
}
inline ::protocol::flex_agent_reconfiguration* flexran_message::unsafe_arena_release_agent_reconfiguration_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.agent_reconfiguration_msg)
  if (_internal_has_agent_reconfiguration_msg()) {
    clear_has_msg();
    ::protocol::flex_agent_reconfiguration* temp = msg_.agent_reconfiguration_msg_;
    msg_.agent_reconfiguration_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_agent_reconfiguration_msg(::protocol::flex_agent_reconfiguration* agent_reconfiguration_msg) {
  clear_msg();
  if (agent_reconfiguration_msg) {
    set_has_agent_reconfiguration_msg();
    msg_.agent_reconfiguration_msg_ = agent_reconfiguration_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.agent_reconfiguration_msg)
}
inline ::protocol::flex_agent_reconfiguration* flexran_message::_internal_mutable_agent_reconfiguration_msg() {
  if (!_internal_has_agent_reconfiguration_msg()) {
    clear_msg();
    set_has_agent_reconfiguration_msg();
    msg_.agent_reconfiguration_msg_ = CreateMaybeMessage< ::protocol::flex_agent_reconfiguration >(GetArena());
  }
  return msg_.agent_reconfiguration_msg_;
}
inline ::protocol::flex_agent_reconfiguration* flexran_message::mutable_agent_reconfiguration_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.agent_reconfiguration_msg)
  return _internal_mutable_agent_reconfiguration_msg();
}

// .protocol.flex_rrc_triggering rrc_triggering = 18;
inline bool flexran_message::_internal_has_rrc_triggering() const {
  return msg_case() == kRrcTriggering;
}
inline bool flexran_message::has_rrc_triggering() const {
  return _internal_has_rrc_triggering();
}
inline void flexran_message::set_has_rrc_triggering() {
  _oneof_case_[0] = kRrcTriggering;
}
inline void flexran_message::clear_rrc_triggering() {
  if (_internal_has_rrc_triggering()) {
    if (GetArena() == nullptr) {
      delete msg_.rrc_triggering_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_rrc_triggering* flexran_message::release_rrc_triggering() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.rrc_triggering)
  if (_internal_has_rrc_triggering()) {
    clear_has_msg();
      ::protocol::flex_rrc_triggering* temp = msg_.rrc_triggering_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.rrc_triggering_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_rrc_triggering& flexran_message::_internal_rrc_triggering() const {
  return _internal_has_rrc_triggering()
      ? *msg_.rrc_triggering_
      : *reinterpret_cast< ::protocol::flex_rrc_triggering*>(&::protocol::_flex_rrc_triggering_default_instance_);
}
inline const ::protocol::flex_rrc_triggering& flexran_message::rrc_triggering() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.rrc_triggering)
  return _internal_rrc_triggering();
}
inline ::protocol::flex_rrc_triggering* flexran_message::unsafe_arena_release_rrc_triggering() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.rrc_triggering)
  if (_internal_has_rrc_triggering()) {
    clear_has_msg();
    ::protocol::flex_rrc_triggering* temp = msg_.rrc_triggering_;
    msg_.rrc_triggering_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_rrc_triggering(::protocol::flex_rrc_triggering* rrc_triggering) {
  clear_msg();
  if (rrc_triggering) {
    set_has_rrc_triggering();
    msg_.rrc_triggering_ = rrc_triggering;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.rrc_triggering)
}
inline ::protocol::flex_rrc_triggering* flexran_message::_internal_mutable_rrc_triggering() {
  if (!_internal_has_rrc_triggering()) {
    clear_msg();
    set_has_rrc_triggering();
    msg_.rrc_triggering_ = CreateMaybeMessage< ::protocol::flex_rrc_triggering >(GetArena());
  }
  return msg_.rrc_triggering_;
}
inline ::protocol::flex_rrc_triggering* flexran_message::mutable_rrc_triggering() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.rrc_triggering)
  return _internal_mutable_rrc_triggering();
}

// .protocol.flex_ul_mac_config ul_mac_config_msg = 19;
inline bool flexran_message::_internal_has_ul_mac_config_msg() const {
  return msg_case() == kUlMacConfigMsg;
}
inline bool flexran_message::has_ul_mac_config_msg() const {
  return _internal_has_ul_mac_config_msg();
}
inline void flexran_message::set_has_ul_mac_config_msg() {
  _oneof_case_[0] = kUlMacConfigMsg;
}
inline void flexran_message::clear_ul_mac_config_msg() {
  if (_internal_has_ul_mac_config_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.ul_mac_config_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_ul_mac_config* flexran_message::release_ul_mac_config_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ul_mac_config_msg)
  if (_internal_has_ul_mac_config_msg()) {
    clear_has_msg();
      ::protocol::flex_ul_mac_config* temp = msg_.ul_mac_config_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ul_mac_config_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_ul_mac_config& flexran_message::_internal_ul_mac_config_msg() const {
  return _internal_has_ul_mac_config_msg()
      ? *msg_.ul_mac_config_msg_
      : *reinterpret_cast< ::protocol::flex_ul_mac_config*>(&::protocol::_flex_ul_mac_config_default_instance_);
}
inline const ::protocol::flex_ul_mac_config& flexran_message::ul_mac_config_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ul_mac_config_msg)
  return _internal_ul_mac_config_msg();
}
inline ::protocol::flex_ul_mac_config* flexran_message::unsafe_arena_release_ul_mac_config_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.ul_mac_config_msg)
  if (_internal_has_ul_mac_config_msg()) {
    clear_has_msg();
    ::protocol::flex_ul_mac_config* temp = msg_.ul_mac_config_msg_;
    msg_.ul_mac_config_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_ul_mac_config_msg(::protocol::flex_ul_mac_config* ul_mac_config_msg) {
  clear_msg();
  if (ul_mac_config_msg) {
    set_has_ul_mac_config_msg();
    msg_.ul_mac_config_msg_ = ul_mac_config_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.ul_mac_config_msg)
}
inline ::protocol::flex_ul_mac_config* flexran_message::_internal_mutable_ul_mac_config_msg() {
  if (!_internal_has_ul_mac_config_msg()) {
    clear_msg();
    set_has_ul_mac_config_msg();
    msg_.ul_mac_config_msg_ = CreateMaybeMessage< ::protocol::flex_ul_mac_config >(GetArena());
  }
  return msg_.ul_mac_config_msg_;
}
inline ::protocol::flex_ul_mac_config* flexran_message::mutable_ul_mac_config_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ul_mac_config_msg)
  return _internal_mutable_ul_mac_config_msg();
}

// .protocol.flex_disconnect disconnect_msg = 20;
inline bool flexran_message::_internal_has_disconnect_msg() const {
  return msg_case() == kDisconnectMsg;
}
inline bool flexran_message::has_disconnect_msg() const {
  return _internal_has_disconnect_msg();
}
inline void flexran_message::set_has_disconnect_msg() {
  _oneof_case_[0] = kDisconnectMsg;
}
inline void flexran_message::clear_disconnect_msg() {
  if (_internal_has_disconnect_msg()) {
    if (GetArena() == nullptr) {
      delete msg_.disconnect_msg_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_disconnect* flexran_message::release_disconnect_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.disconnect_msg)
  if (_internal_has_disconnect_msg()) {
    clear_has_msg();
      ::protocol::flex_disconnect* temp = msg_.disconnect_msg_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.disconnect_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_disconnect& flexran_message::_internal_disconnect_msg() const {
  return _internal_has_disconnect_msg()
      ? *msg_.disconnect_msg_
      : *reinterpret_cast< ::protocol::flex_disconnect*>(&::protocol::_flex_disconnect_default_instance_);
}
inline const ::protocol::flex_disconnect& flexran_message::disconnect_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.disconnect_msg)
  return _internal_disconnect_msg();
}
inline ::protocol::flex_disconnect* flexran_message::unsafe_arena_release_disconnect_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.disconnect_msg)
  if (_internal_has_disconnect_msg()) {
    clear_has_msg();
    ::protocol::flex_disconnect* temp = msg_.disconnect_msg_;
    msg_.disconnect_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_disconnect_msg(::protocol::flex_disconnect* disconnect_msg) {
  clear_msg();
  if (disconnect_msg) {
    set_has_disconnect_msg();
    msg_.disconnect_msg_ = disconnect_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.disconnect_msg)
}
inline ::protocol::flex_disconnect* flexran_message::_internal_mutable_disconnect_msg() {
  if (!_internal_has_disconnect_msg()) {
    clear_msg();
    set_has_disconnect_msg();
    msg_.disconnect_msg_ = CreateMaybeMessage< ::protocol::flex_disconnect >(GetArena());
  }
  return msg_.disconnect_msg_;
}
inline ::protocol::flex_disconnect* flexran_message::mutable_disconnect_msg() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.disconnect_msg)
  return _internal_mutable_disconnect_msg();
}

// .protocol.flex_ho_command ho_command = 21;
inline bool flexran_message::_internal_has_ho_command() const {
  return msg_case() == kHoCommand;
}
inline bool flexran_message::has_ho_command() const {
  return _internal_has_ho_command();
}
inline void flexran_message::set_has_ho_command() {
  _oneof_case_[0] = kHoCommand;
}
inline void flexran_message::clear_ho_command() {
  if (_internal_has_ho_command()) {
    if (GetArena() == nullptr) {
      delete msg_.ho_command_;
    }
    clear_has_msg();
  }
}
inline ::protocol::flex_ho_command* flexran_message::release_ho_command() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ho_command)
  if (_internal_has_ho_command()) {
    clear_has_msg();
      ::protocol::flex_ho_command* temp = msg_.ho_command_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ho_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_ho_command& flexran_message::_internal_ho_command() const {
  return _internal_has_ho_command()
      ? *msg_.ho_command_
      : *reinterpret_cast< ::protocol::flex_ho_command*>(&::protocol::_flex_ho_command_default_instance_);
}
inline const ::protocol::flex_ho_command& flexran_message::ho_command() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ho_command)
  return _internal_ho_command();
}
inline ::protocol::flex_ho_command* flexran_message::unsafe_arena_release_ho_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flexran_message.ho_command)
  if (_internal_has_ho_command()) {
    clear_has_msg();
    ::protocol::flex_ho_command* temp = msg_.ho_command_;
    msg_.ho_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flexran_message::unsafe_arena_set_allocated_ho_command(::protocol::flex_ho_command* ho_command) {
  clear_msg();
  if (ho_command) {
    set_has_ho_command();
    msg_.ho_command_ = ho_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flexran_message.ho_command)
}
inline ::protocol::flex_ho_command* flexran_message::_internal_mutable_ho_command() {
  if (!_internal_has_ho_command()) {
    clear_msg();
    set_has_ho_command();
    msg_.ho_command_ = CreateMaybeMessage< ::protocol::flex_ho_command >(GetArena());
  }
  return msg_.ho_command_;
}
inline ::protocol::flex_ho_command* flexran_message::mutable_ho_command() {
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ho_command)
  return _internal_mutable_ho_command();
}

inline bool flexran_message::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void flexran_message::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline flexran_message::MsgCase flexran_message::msg_case() const {
  return flexran_message::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// flex_hello

// optional .protocol.flex_header header = 1;
inline bool flex_hello::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_hello::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_hello::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_hello::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.header)
  return _internal_header();
}
inline void flex_hello::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_hello.header)
}
inline ::protocol::flex_header* flex_hello::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_hello::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_hello.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_hello::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_hello::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_hello.header)
  return _internal_mutable_header();
}
inline void flex_hello::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_hello.header)
}

// optional uint64 bs_id = 2;
inline bool flex_hello::_internal_has_bs_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_hello::has_bs_id() const {
  return _internal_has_bs_id();
}
inline void flex_hello::clear_bs_id() {
  bs_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 flex_hello::_internal_bs_id() const {
  return bs_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 flex_hello::bs_id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.bs_id)
  return _internal_bs_id();
}
inline void flex_hello::_internal_set_bs_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  bs_id_ = value;
}
inline void flex_hello::set_bs_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bs_id(value);
  // @@protoc_insertion_point(field_set:protocol.flex_hello.bs_id)
}

// repeated .protocol.flex_bs_capability capabilities = 3;
inline int flex_hello::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int flex_hello::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void flex_hello::clear_capabilities() {
  capabilities_.Clear();
}
inline ::protocol::flex_bs_capability flex_hello::_internal_capabilities(int index) const {
  return static_cast< ::protocol::flex_bs_capability >(capabilities_.Get(index));
}
inline ::protocol::flex_bs_capability flex_hello::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.capabilities)
  return _internal_capabilities(index);
}
inline void flex_hello::set_capabilities(int index, ::protocol::flex_bs_capability value) {
  assert(::protocol::flex_bs_capability_IsValid(value));
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_hello.capabilities)
}
inline void flex_hello::_internal_add_capabilities(::protocol::flex_bs_capability value) {
  assert(::protocol::flex_bs_capability_IsValid(value));
  capabilities_.Add(value);
}
inline void flex_hello::add_capabilities(::protocol::flex_bs_capability value) {
  // @@protoc_insertion_point(field_add:protocol.flex_hello.capabilities)
  _internal_add_capabilities(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
flex_hello::capabilities() const {
  // @@protoc_insertion_point(field_list:protocol.flex_hello.capabilities)
  return capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
flex_hello::_internal_mutable_capabilities() {
  return &capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
flex_hello::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_hello.capabilities)
  return _internal_mutable_capabilities();
}

// repeated .protocol.flex_bs_split splits = 4;
inline int flex_hello::_internal_splits_size() const {
  return splits_.size();
}
inline int flex_hello::splits_size() const {
  return _internal_splits_size();
}
inline void flex_hello::clear_splits() {
  splits_.Clear();
}
inline ::protocol::flex_bs_split flex_hello::_internal_splits(int index) const {
  return static_cast< ::protocol::flex_bs_split >(splits_.Get(index));
}
inline ::protocol::flex_bs_split flex_hello::splits(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.splits)
  return _internal_splits(index);
}
inline void flex_hello::set_splits(int index, ::protocol::flex_bs_split value) {
  assert(::protocol::flex_bs_split_IsValid(value));
  splits_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_hello.splits)
}
inline void flex_hello::_internal_add_splits(::protocol::flex_bs_split value) {
  assert(::protocol::flex_bs_split_IsValid(value));
  splits_.Add(value);
}
inline void flex_hello::add_splits(::protocol::flex_bs_split value) {
  // @@protoc_insertion_point(field_add:protocol.flex_hello.splits)
  _internal_add_splits(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
flex_hello::splits() const {
  // @@protoc_insertion_point(field_list:protocol.flex_hello.splits)
  return splits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
flex_hello::_internal_mutable_splits() {
  return &splits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
flex_hello::mutable_splits() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_hello.splits)
  return _internal_mutable_splits();
}

// -------------------------------------------------------------------

// flex_echo_request

// optional .protocol.flex_header header = 1;
inline bool flex_echo_request::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_echo_request::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_echo_request::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_echo_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_echo_request.header)
  return _internal_header();
}
inline void flex_echo_request::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_echo_request.header)
}
inline ::protocol::flex_header* flex_echo_request::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_echo_request::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_echo_request.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_echo_request::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_echo_request::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_echo_request.header)
  return _internal_mutable_header();
}
inline void flex_echo_request::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_echo_request.header)
}

// -------------------------------------------------------------------

// flex_echo_reply

// optional .protocol.flex_header header = 1;
inline bool flex_echo_reply::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_echo_reply::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_echo_reply::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_echo_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_echo_reply.header)
  return _internal_header();
}
inline void flex_echo_reply::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_echo_reply.header)
}
inline ::protocol::flex_header* flex_echo_reply::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_echo_reply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_echo_reply.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_echo_reply::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_echo_reply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_echo_reply.header)
  return _internal_mutable_header();
}
inline void flex_echo_reply::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_echo_reply.header)
}

// -------------------------------------------------------------------

// flex_stats_request

// optional .protocol.flex_header header = 1;
inline bool flex_stats_request::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_stats_request::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_stats_request::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_stats_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.header)
  return _internal_header();
}
inline void flex_stats_request::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_stats_request.header)
}
inline ::protocol::flex_header* flex_stats_request::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_stats_request::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_stats_request::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_stats_request::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.header)
  return _internal_mutable_header();
}
inline void flex_stats_request::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_stats_request.header)
}

// optional .protocol.flex_stats_type type = 2;
inline bool flex_stats_request::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_stats_request::has_type() const {
  return _internal_has_type();
}
inline void flex_stats_request::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::protocol::flex_stats_type flex_stats_request::_internal_type() const {
  return static_cast< ::protocol::flex_stats_type >(type_);
}
inline ::protocol::flex_stats_type flex_stats_request::type() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.type)
  return _internal_type();
}
inline void flex_stats_request::_internal_set_type(::protocol::flex_stats_type value) {
  assert(::protocol::flex_stats_type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void flex_stats_request::set_type(::protocol::flex_stats_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.flex_stats_request.type)
}

// .protocol.flex_complete_stats_request complete_stats_request = 3;
inline bool flex_stats_request::_internal_has_complete_stats_request() const {
  return body_case() == kCompleteStatsRequest;
}
inline bool flex_stats_request::has_complete_stats_request() const {
  return _internal_has_complete_stats_request();
}
inline void flex_stats_request::set_has_complete_stats_request() {
  _oneof_case_[0] = kCompleteStatsRequest;
}
inline ::protocol::flex_complete_stats_request* flex_stats_request::release_complete_stats_request() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.complete_stats_request)
  if (_internal_has_complete_stats_request()) {
    clear_has_body();
      ::protocol::flex_complete_stats_request* temp = body_.complete_stats_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.complete_stats_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_complete_stats_request& flex_stats_request::_internal_complete_stats_request() const {
  return _internal_has_complete_stats_request()
      ? *body_.complete_stats_request_
      : *reinterpret_cast< ::protocol::flex_complete_stats_request*>(&::protocol::_flex_complete_stats_request_default_instance_);
}
inline const ::protocol::flex_complete_stats_request& flex_stats_request::complete_stats_request() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.complete_stats_request)
  return _internal_complete_stats_request();
}
inline ::protocol::flex_complete_stats_request* flex_stats_request::unsafe_arena_release_complete_stats_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flex_stats_request.complete_stats_request)
  if (_internal_has_complete_stats_request()) {
    clear_has_body();
    ::protocol::flex_complete_stats_request* temp = body_.complete_stats_request_;
    body_.complete_stats_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flex_stats_request::unsafe_arena_set_allocated_complete_stats_request(::protocol::flex_complete_stats_request* complete_stats_request) {
  clear_body();
  if (complete_stats_request) {
    set_has_complete_stats_request();
    body_.complete_stats_request_ = complete_stats_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_stats_request.complete_stats_request)
}
inline ::protocol::flex_complete_stats_request* flex_stats_request::_internal_mutable_complete_stats_request() {
  if (!_internal_has_complete_stats_request()) {
    clear_body();
    set_has_complete_stats_request();
    body_.complete_stats_request_ = CreateMaybeMessage< ::protocol::flex_complete_stats_request >(GetArena());
  }
  return body_.complete_stats_request_;
}
inline ::protocol::flex_complete_stats_request* flex_stats_request::mutable_complete_stats_request() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.complete_stats_request)
  return _internal_mutable_complete_stats_request();
}

// .protocol.flex_cell_stats_request cell_stats_request = 4;
inline bool flex_stats_request::_internal_has_cell_stats_request() const {
  return body_case() == kCellStatsRequest;
}
inline bool flex_stats_request::has_cell_stats_request() const {
  return _internal_has_cell_stats_request();
}
inline void flex_stats_request::set_has_cell_stats_request() {
  _oneof_case_[0] = kCellStatsRequest;
}
inline ::protocol::flex_cell_stats_request* flex_stats_request::release_cell_stats_request() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.cell_stats_request)
  if (_internal_has_cell_stats_request()) {
    clear_has_body();
      ::protocol::flex_cell_stats_request* temp = body_.cell_stats_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.cell_stats_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_cell_stats_request& flex_stats_request::_internal_cell_stats_request() const {
  return _internal_has_cell_stats_request()
      ? *body_.cell_stats_request_
      : *reinterpret_cast< ::protocol::flex_cell_stats_request*>(&::protocol::_flex_cell_stats_request_default_instance_);
}
inline const ::protocol::flex_cell_stats_request& flex_stats_request::cell_stats_request() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.cell_stats_request)
  return _internal_cell_stats_request();
}
inline ::protocol::flex_cell_stats_request* flex_stats_request::unsafe_arena_release_cell_stats_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flex_stats_request.cell_stats_request)
  if (_internal_has_cell_stats_request()) {
    clear_has_body();
    ::protocol::flex_cell_stats_request* temp = body_.cell_stats_request_;
    body_.cell_stats_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flex_stats_request::unsafe_arena_set_allocated_cell_stats_request(::protocol::flex_cell_stats_request* cell_stats_request) {
  clear_body();
  if (cell_stats_request) {
    set_has_cell_stats_request();
    body_.cell_stats_request_ = cell_stats_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_stats_request.cell_stats_request)
}
inline ::protocol::flex_cell_stats_request* flex_stats_request::_internal_mutable_cell_stats_request() {
  if (!_internal_has_cell_stats_request()) {
    clear_body();
    set_has_cell_stats_request();
    body_.cell_stats_request_ = CreateMaybeMessage< ::protocol::flex_cell_stats_request >(GetArena());
  }
  return body_.cell_stats_request_;
}
inline ::protocol::flex_cell_stats_request* flex_stats_request::mutable_cell_stats_request() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.cell_stats_request)
  return _internal_mutable_cell_stats_request();
}

// .protocol.flex_ue_stats_request ue_stats_request = 5;
inline bool flex_stats_request::_internal_has_ue_stats_request() const {
  return body_case() == kUeStatsRequest;
}
inline bool flex_stats_request::has_ue_stats_request() const {
  return _internal_has_ue_stats_request();
}
inline void flex_stats_request::set_has_ue_stats_request() {
  _oneof_case_[0] = kUeStatsRequest;
}
inline ::protocol::flex_ue_stats_request* flex_stats_request::release_ue_stats_request() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.ue_stats_request)
  if (_internal_has_ue_stats_request()) {
    clear_has_body();
      ::protocol::flex_ue_stats_request* temp = body_.ue_stats_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.ue_stats_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protocol::flex_ue_stats_request& flex_stats_request::_internal_ue_stats_request() const {
  return _internal_has_ue_stats_request()
      ? *body_.ue_stats_request_
      : *reinterpret_cast< ::protocol::flex_ue_stats_request*>(&::protocol::_flex_ue_stats_request_default_instance_);
}
inline const ::protocol::flex_ue_stats_request& flex_stats_request::ue_stats_request() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.ue_stats_request)
  return _internal_ue_stats_request();
}
inline ::protocol::flex_ue_stats_request* flex_stats_request::unsafe_arena_release_ue_stats_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.flex_stats_request.ue_stats_request)
  if (_internal_has_ue_stats_request()) {
    clear_has_body();
    ::protocol::flex_ue_stats_request* temp = body_.ue_stats_request_;
    body_.ue_stats_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void flex_stats_request::unsafe_arena_set_allocated_ue_stats_request(::protocol::flex_ue_stats_request* ue_stats_request) {
  clear_body();
  if (ue_stats_request) {
    set_has_ue_stats_request();
    body_.ue_stats_request_ = ue_stats_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_stats_request.ue_stats_request)
}
inline ::protocol::flex_ue_stats_request* flex_stats_request::_internal_mutable_ue_stats_request() {
  if (!_internal_has_ue_stats_request()) {
    clear_body();
    set_has_ue_stats_request();
    body_.ue_stats_request_ = CreateMaybeMessage< ::protocol::flex_ue_stats_request >(GetArena());
  }
  return body_.ue_stats_request_;
}
inline ::protocol::flex_ue_stats_request* flex_stats_request::mutable_ue_stats_request() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.ue_stats_request)
  return _internal_mutable_ue_stats_request();
}

inline bool flex_stats_request::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void flex_stats_request::clear_has_body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline flex_stats_request::BodyCase flex_stats_request::body_case() const {
  return flex_stats_request::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// flex_stats_reply

// optional .protocol.flex_header header = 1;
inline bool flex_stats_reply::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_stats_reply::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_stats_reply::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_stats_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_reply.header)
  return _internal_header();
}
inline void flex_stats_reply::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_stats_reply.header)
}
inline ::protocol::flex_header* flex_stats_reply::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_stats_reply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_reply.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_stats_reply::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_stats_reply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_reply.header)
  return _internal_mutable_header();
}
inline void flex_stats_reply::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_stats_reply.header)
}

// repeated .protocol.flex_ue_stats_report ue_report = 2;
inline int flex_stats_reply::_internal_ue_report_size() const {
  return ue_report_.size();
}
inline int flex_stats_reply::ue_report_size() const {
  return _internal_ue_report_size();
}
inline ::protocol::flex_ue_stats_report* flex_stats_reply::mutable_ue_report(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_reply.ue_report)
  return ue_report_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_stats_report >*
flex_stats_reply::mutable_ue_report() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_stats_reply.ue_report)
  return &ue_report_;
}
inline const ::protocol::flex_ue_stats_report& flex_stats_reply::_internal_ue_report(int index) const {
  return ue_report_.Get(index);
}
inline const ::protocol::flex_ue_stats_report& flex_stats_reply::ue_report(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_reply.ue_report)
  return _internal_ue_report(index);
}
inline ::protocol::flex_ue_stats_report* flex_stats_reply::_internal_add_ue_report() {
  return ue_report_.Add();
}
inline ::protocol::flex_ue_stats_report* flex_stats_reply::add_ue_report() {
  // @@protoc_insertion_point(field_add:protocol.flex_stats_reply.ue_report)
  return _internal_add_ue_report();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_stats_report >&
flex_stats_reply::ue_report() const {
  // @@protoc_insertion_point(field_list:protocol.flex_stats_reply.ue_report)
  return ue_report_;
}

// repeated .protocol.flex_cell_stats_report cell_report = 3;
inline int flex_stats_reply::_internal_cell_report_size() const {
  return cell_report_.size();
}
inline int flex_stats_reply::cell_report_size() const {
  return _internal_cell_report_size();
}
inline ::protocol::flex_cell_stats_report* flex_stats_reply::mutable_cell_report(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_reply.cell_report)
  return cell_report_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_stats_report >*
flex_stats_reply::mutable_cell_report() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_stats_reply.cell_report)
  return &cell_report_;
}
inline const ::protocol::flex_cell_stats_report& flex_stats_reply::_internal_cell_report(int index) const {
  return cell_report_.Get(index);
}
inline const ::protocol::flex_cell_stats_report& flex_stats_reply::cell_report(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_reply.cell_report)
  return _internal_cell_report(index);
}
inline ::protocol::flex_cell_stats_report* flex_stats_reply::_internal_add_cell_report() {
  return cell_report_.Add();
}
inline ::protocol::flex_cell_stats_report* flex_stats_reply::add_cell_report() {
  // @@protoc_insertion_point(field_add:protocol.flex_stats_reply.cell_report)
  return _internal_add_cell_report();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_stats_report >&
flex_stats_reply::cell_report() const {
  // @@protoc_insertion_point(field_list:protocol.flex_stats_reply.cell_report)
  return cell_report_;
}

// -------------------------------------------------------------------

// flex_sf_trigger

// optional .protocol.flex_header header = 1;
inline bool flex_sf_trigger::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_sf_trigger::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_sf_trigger::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_sf_trigger::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.header)
  return _internal_header();
}
inline void flex_sf_trigger::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_sf_trigger.header)
}
inline ::protocol::flex_header* flex_sf_trigger::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_sf_trigger::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_sf_trigger.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_sf_trigger::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_sf_trigger::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_sf_trigger.header)
  return _internal_mutable_header();
}
inline void flex_sf_trigger::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_sf_trigger.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_sf_trigger::_internal_has_sfn_sf() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_sf_trigger::has_sfn_sf() const {
  return _internal_has_sfn_sf();
}
inline void flex_sf_trigger::clear_sfn_sf() {
  sfn_sf_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_sf_trigger::_internal_sfn_sf() const {
  return sfn_sf_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_sf_trigger::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.sfn_sf)
  return _internal_sfn_sf();
}
inline void flex_sf_trigger::_internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sfn_sf_ = value;
}
inline void flex_sf_trigger::set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sfn_sf(value);
  // @@protoc_insertion_point(field_set:protocol.flex_sf_trigger.sfn_sf)
}

// repeated .protocol.flex_dl_info dl_info = 3;
inline int flex_sf_trigger::_internal_dl_info_size() const {
  return dl_info_.size();
}
inline int flex_sf_trigger::dl_info_size() const {
  return _internal_dl_info_size();
}
inline ::protocol::flex_dl_info* flex_sf_trigger::mutable_dl_info(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_sf_trigger.dl_info)
  return dl_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_info >*
flex_sf_trigger::mutable_dl_info() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_sf_trigger.dl_info)
  return &dl_info_;
}
inline const ::protocol::flex_dl_info& flex_sf_trigger::_internal_dl_info(int index) const {
  return dl_info_.Get(index);
}
inline const ::protocol::flex_dl_info& flex_sf_trigger::dl_info(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.dl_info)
  return _internal_dl_info(index);
}
inline ::protocol::flex_dl_info* flex_sf_trigger::_internal_add_dl_info() {
  return dl_info_.Add();
}
inline ::protocol::flex_dl_info* flex_sf_trigger::add_dl_info() {
  // @@protoc_insertion_point(field_add:protocol.flex_sf_trigger.dl_info)
  return _internal_add_dl_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_info >&
flex_sf_trigger::dl_info() const {
  // @@protoc_insertion_point(field_list:protocol.flex_sf_trigger.dl_info)
  return dl_info_;
}

// repeated .protocol.flex_ul_info ul_info = 4;
inline int flex_sf_trigger::_internal_ul_info_size() const {
  return ul_info_.size();
}
inline int flex_sf_trigger::ul_info_size() const {
  return _internal_ul_info_size();
}
inline ::protocol::flex_ul_info* flex_sf_trigger::mutable_ul_info(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_sf_trigger.ul_info)
  return ul_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_info >*
flex_sf_trigger::mutable_ul_info() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_sf_trigger.ul_info)
  return &ul_info_;
}
inline const ::protocol::flex_ul_info& flex_sf_trigger::_internal_ul_info(int index) const {
  return ul_info_.Get(index);
}
inline const ::protocol::flex_ul_info& flex_sf_trigger::ul_info(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.ul_info)
  return _internal_ul_info(index);
}
inline ::protocol::flex_ul_info* flex_sf_trigger::_internal_add_ul_info() {
  return ul_info_.Add();
}
inline ::protocol::flex_ul_info* flex_sf_trigger::add_ul_info() {
  // @@protoc_insertion_point(field_add:protocol.flex_sf_trigger.ul_info)
  return _internal_add_ul_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_info >&
flex_sf_trigger::ul_info() const {
  // @@protoc_insertion_point(field_list:protocol.flex_sf_trigger.ul_info)
  return ul_info_;
}

// -------------------------------------------------------------------

// flex_ul_sr_info

// optional .protocol.flex_header header = 1;
inline bool flex_ul_sr_info::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_ul_sr_info::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_ul_sr_info::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_ul_sr_info::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_sr_info.header)
  return _internal_header();
}
inline void flex_ul_sr_info::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_ul_sr_info.header)
}
inline ::protocol::flex_header* flex_ul_sr_info::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_ul_sr_info::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ul_sr_info.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_ul_sr_info::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_ul_sr_info::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ul_sr_info.header)
  return _internal_mutable_header();
}
inline void flex_ul_sr_info::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ul_sr_info.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_ul_sr_info::_internal_has_sfn_sf() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_ul_sr_info::has_sfn_sf() const {
  return _internal_has_sfn_sf();
}
inline void flex_ul_sr_info::clear_sfn_sf() {
  sfn_sf_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ul_sr_info::_internal_sfn_sf() const {
  return sfn_sf_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ul_sr_info::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_sr_info.sfn_sf)
  return _internal_sfn_sf();
}
inline void flex_ul_sr_info::_internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sfn_sf_ = value;
}
inline void flex_ul_sr_info::set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sfn_sf(value);
  // @@protoc_insertion_point(field_set:protocol.flex_ul_sr_info.sfn_sf)
}

// repeated uint32 rnti = 3;
inline int flex_ul_sr_info::_internal_rnti_size() const {
  return rnti_.size();
}
inline int flex_ul_sr_info::rnti_size() const {
  return _internal_rnti_size();
}
inline void flex_ul_sr_info::clear_rnti() {
  rnti_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ul_sr_info::_internal_rnti(int index) const {
  return rnti_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ul_sr_info::rnti(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_sr_info.rnti)
  return _internal_rnti(index);
}
inline void flex_ul_sr_info::set_rnti(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  rnti_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_ul_sr_info.rnti)
}
inline void flex_ul_sr_info::_internal_add_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  rnti_.Add(value);
}
inline void flex_ul_sr_info::add_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_rnti(value);
  // @@protoc_insertion_point(field_add:protocol.flex_ul_sr_info.rnti)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
flex_ul_sr_info::_internal_rnti() const {
  return rnti_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
flex_ul_sr_info::rnti() const {
  // @@protoc_insertion_point(field_list:protocol.flex_ul_sr_info.rnti)
  return _internal_rnti();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
flex_ul_sr_info::_internal_mutable_rnti() {
  return &rnti_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
flex_ul_sr_info::mutable_rnti() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_ul_sr_info.rnti)
  return _internal_mutable_rnti();
}

// -------------------------------------------------------------------

// flex_enb_config_request

// optional .protocol.flex_header header = 1;
inline bool flex_enb_config_request::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_enb_config_request::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_enb_config_request::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_enb_config_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_request.header)
  return _internal_header();
}
inline void flex_enb_config_request::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_enb_config_request.header)
}
inline ::protocol::flex_header* flex_enb_config_request::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_enb_config_request::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_enb_config_request.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_enb_config_request::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_enb_config_request::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_request.header)
  return _internal_mutable_header();
}
inline void flex_enb_config_request::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_enb_config_request.header)
}

// -------------------------------------------------------------------

// flex_enb_config_reply

// optional .protocol.flex_header header = 1;
inline bool flex_enb_config_reply::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_enb_config_reply::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_enb_config_reply::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_enb_config_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.header)
  return _internal_header();
}
inline void flex_enb_config_reply::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_enb_config_reply.header)
}
inline ::protocol::flex_header* flex_enb_config_reply::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_enb_config_reply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_enb_config_reply.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_enb_config_reply::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_enb_config_reply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_reply.header)
  return _internal_mutable_header();
}
inline void flex_enb_config_reply::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_enb_config_reply.header)
}

// optional uint64 eNB_id = 2;
inline bool flex_enb_config_reply::_internal_has_enb_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool flex_enb_config_reply::has_enb_id() const {
  return _internal_has_enb_id();
}
inline void flex_enb_config_reply::clear_enb_id() {
  enb_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 flex_enb_config_reply::_internal_enb_id() const {
  return enb_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 flex_enb_config_reply::enb_id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.eNB_id)
  return _internal_enb_id();
}
inline void flex_enb_config_reply::_internal_set_enb_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  enb_id_ = value;
}
inline void flex_enb_config_reply::set_enb_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_enb_id(value);
  // @@protoc_insertion_point(field_set:protocol.flex_enb_config_reply.eNB_id)
}

// repeated .protocol.flex_cell_config cell_config = 3;
inline int flex_enb_config_reply::_internal_cell_config_size() const {
  return cell_config_.size();
}
inline int flex_enb_config_reply::cell_config_size() const {
  return _internal_cell_config_size();
}
inline ::protocol::flex_cell_config* flex_enb_config_reply::mutable_cell_config(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_reply.cell_config)
  return cell_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_config >*
flex_enb_config_reply::mutable_cell_config() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_enb_config_reply.cell_config)
  return &cell_config_;
}
inline const ::protocol::flex_cell_config& flex_enb_config_reply::_internal_cell_config(int index) const {
  return cell_config_.Get(index);
}
inline const ::protocol::flex_cell_config& flex_enb_config_reply::cell_config(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.cell_config)
  return _internal_cell_config(index);
}
inline ::protocol::flex_cell_config* flex_enb_config_reply::_internal_add_cell_config() {
  return cell_config_.Add();
}
inline ::protocol::flex_cell_config* flex_enb_config_reply::add_cell_config() {
  // @@protoc_insertion_point(field_add:protocol.flex_enb_config_reply.cell_config)
  return _internal_add_cell_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_cell_config >&
flex_enb_config_reply::cell_config() const {
  // @@protoc_insertion_point(field_list:protocol.flex_enb_config_reply.cell_config)
  return cell_config_;
}

// optional uint32 device_spec = 4;
inline bool flex_enb_config_reply::_internal_has_device_spec() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool flex_enb_config_reply::has_device_spec() const {
  return _internal_has_device_spec();
}
inline void flex_enb_config_reply::clear_device_spec() {
  device_spec_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_enb_config_reply::_internal_device_spec() const {
  return device_spec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_enb_config_reply::device_spec() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.device_spec)
  return _internal_device_spec();
}
inline void flex_enb_config_reply::_internal_set_device_spec(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  device_spec_ = value;
}
inline void flex_enb_config_reply::set_device_spec(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_device_spec(value);
  // @@protoc_insertion_point(field_set:protocol.flex_enb_config_reply.device_spec)
}

// optional .protocol.flex_s1ap_config s1ap = 5;
inline bool flex_enb_config_reply::_internal_has_s1ap() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || s1ap_ != nullptr);
  return value;
}
inline bool flex_enb_config_reply::has_s1ap() const {
  return _internal_has_s1ap();
}
inline const ::protocol::flex_s1ap_config& flex_enb_config_reply::_internal_s1ap() const {
  const ::protocol::flex_s1ap_config* p = s1ap_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_s1ap_config*>(
      &::protocol::_flex_s1ap_config_default_instance_);
}
inline const ::protocol::flex_s1ap_config& flex_enb_config_reply::s1ap() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.s1ap)
  return _internal_s1ap();
}
inline void flex_enb_config_reply::unsafe_arena_set_allocated_s1ap(
    ::protocol::flex_s1ap_config* s1ap) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s1ap_);
  }
  s1ap_ = s1ap;
  if (s1ap) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_enb_config_reply.s1ap)
}
inline ::protocol::flex_s1ap_config* flex_enb_config_reply::release_s1ap() {
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_s1ap_config* temp = s1ap_;
  s1ap_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_s1ap_config* flex_enb_config_reply::unsafe_arena_release_s1ap() {
  // @@protoc_insertion_point(field_release:protocol.flex_enb_config_reply.s1ap)
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_s1ap_config* temp = s1ap_;
  s1ap_ = nullptr;
  return temp;
}
inline ::protocol::flex_s1ap_config* flex_enb_config_reply::_internal_mutable_s1ap() {
  _has_bits_[0] |= 0x00000002u;
  if (s1ap_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_s1ap_config>(GetArena());
    s1ap_ = p;
  }
  return s1ap_;
}
inline ::protocol::flex_s1ap_config* flex_enb_config_reply::mutable_s1ap() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_reply.s1ap)
  return _internal_mutable_s1ap();
}
inline void flex_enb_config_reply::set_allocated_s1ap(::protocol::flex_s1ap_config* s1ap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(s1ap_);
  }
  if (s1ap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s1ap)->GetArena();
    if (message_arena != submessage_arena) {
      s1ap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s1ap, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  s1ap_ = s1ap;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_enb_config_reply.s1ap)
}

// -------------------------------------------------------------------

// flex_ue_config_request

// optional .protocol.flex_header header = 1;
inline bool flex_ue_config_request::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_ue_config_request::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_ue_config_request::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_ue_config_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_config_request.header)
  return _internal_header();
}
inline void flex_ue_config_request::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_ue_config_request.header)
}
inline ::protocol::flex_header* flex_ue_config_request::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_ue_config_request::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_config_request.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_ue_config_request::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_ue_config_request::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_config_request.header)
  return _internal_mutable_header();
}
inline void flex_ue_config_request::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_config_request.header)
}

// -------------------------------------------------------------------

// flex_ue_config_reply

// optional .protocol.flex_header header = 1;
inline bool flex_ue_config_reply::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_ue_config_reply::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_ue_config_reply::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_ue_config_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_config_reply.header)
  return _internal_header();
}
inline void flex_ue_config_reply::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_ue_config_reply.header)
}
inline ::protocol::flex_header* flex_ue_config_reply::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_ue_config_reply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_config_reply.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_ue_config_reply::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_ue_config_reply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_config_reply.header)
  return _internal_mutable_header();
}
inline void flex_ue_config_reply::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_config_reply.header)
}

// repeated .protocol.flex_ue_config ue_config = 2;
inline int flex_ue_config_reply::_internal_ue_config_size() const {
  return ue_config_.size();
}
inline int flex_ue_config_reply::ue_config_size() const {
  return _internal_ue_config_size();
}
inline ::protocol::flex_ue_config* flex_ue_config_reply::mutable_ue_config(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_config_reply.ue_config)
  return ue_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_config >*
flex_ue_config_reply::mutable_ue_config() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_ue_config_reply.ue_config)
  return &ue_config_;
}
inline const ::protocol::flex_ue_config& flex_ue_config_reply::_internal_ue_config(int index) const {
  return ue_config_.Get(index);
}
inline const ::protocol::flex_ue_config& flex_ue_config_reply::ue_config(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_config_reply.ue_config)
  return _internal_ue_config(index);
}
inline ::protocol::flex_ue_config* flex_ue_config_reply::_internal_add_ue_config() {
  return ue_config_.Add();
}
inline ::protocol::flex_ue_config* flex_ue_config_reply::add_ue_config() {
  // @@protoc_insertion_point(field_add:protocol.flex_ue_config_reply.ue_config)
  return _internal_add_ue_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ue_config >&
flex_ue_config_reply::ue_config() const {
  // @@protoc_insertion_point(field_list:protocol.flex_ue_config_reply.ue_config)
  return ue_config_;
}

// -------------------------------------------------------------------

// flex_lc_config_request

// optional .protocol.flex_header header = 1;
inline bool flex_lc_config_request::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_lc_config_request::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_lc_config_request::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_lc_config_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config_request.header)
  return _internal_header();
}
inline void flex_lc_config_request::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_lc_config_request.header)
}
inline ::protocol::flex_header* flex_lc_config_request::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_lc_config_request::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_lc_config_request.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_lc_config_request::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_lc_config_request::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_lc_config_request.header)
  return _internal_mutable_header();
}
inline void flex_lc_config_request::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_lc_config_request.header)
}

// -------------------------------------------------------------------

// flex_lc_config_reply

// optional .protocol.flex_header header = 1;
inline bool flex_lc_config_reply::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_lc_config_reply::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_lc_config_reply::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_lc_config_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config_reply.header)
  return _internal_header();
}
inline void flex_lc_config_reply::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_lc_config_reply.header)
}
inline ::protocol::flex_header* flex_lc_config_reply::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_lc_config_reply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_lc_config_reply.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_lc_config_reply::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_lc_config_reply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_lc_config_reply.header)
  return _internal_mutable_header();
}
inline void flex_lc_config_reply::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_lc_config_reply.header)
}

// repeated .protocol.flex_lc_ue_config lc_ue_config = 2;
inline int flex_lc_config_reply::_internal_lc_ue_config_size() const {
  return lc_ue_config_.size();
}
inline int flex_lc_config_reply::lc_ue_config_size() const {
  return _internal_lc_ue_config_size();
}
inline ::protocol::flex_lc_ue_config* flex_lc_config_reply::mutable_lc_ue_config(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_lc_config_reply.lc_ue_config)
  return lc_ue_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_lc_ue_config >*
flex_lc_config_reply::mutable_lc_ue_config() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_lc_config_reply.lc_ue_config)
  return &lc_ue_config_;
}
inline const ::protocol::flex_lc_ue_config& flex_lc_config_reply::_internal_lc_ue_config(int index) const {
  return lc_ue_config_.Get(index);
}
inline const ::protocol::flex_lc_ue_config& flex_lc_config_reply::lc_ue_config(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config_reply.lc_ue_config)
  return _internal_lc_ue_config(index);
}
inline ::protocol::flex_lc_ue_config* flex_lc_config_reply::_internal_add_lc_ue_config() {
  return lc_ue_config_.Add();
}
inline ::protocol::flex_lc_ue_config* flex_lc_config_reply::add_lc_ue_config() {
  // @@protoc_insertion_point(field_add:protocol.flex_lc_config_reply.lc_ue_config)
  return _internal_add_lc_ue_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_lc_ue_config >&
flex_lc_config_reply::lc_ue_config() const {
  // @@protoc_insertion_point(field_list:protocol.flex_lc_config_reply.lc_ue_config)
  return lc_ue_config_;
}

// -------------------------------------------------------------------

// flex_dl_mac_config

// optional .protocol.flex_header header = 1;
inline bool flex_dl_mac_config::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_dl_mac_config::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_dl_mac_config::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_dl_mac_config::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.header)
  return _internal_header();
}
inline void flex_dl_mac_config::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_dl_mac_config.header)
}
inline ::protocol::flex_header* flex_dl_mac_config::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_dl_mac_config::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_dl_mac_config.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_dl_mac_config::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_dl_mac_config::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.header)
  return _internal_mutable_header();
}
inline void flex_dl_mac_config::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_dl_mac_config.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_dl_mac_config::_internal_has_sfn_sf() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_dl_mac_config::has_sfn_sf() const {
  return _internal_has_sfn_sf();
}
inline void flex_dl_mac_config::clear_sfn_sf() {
  sfn_sf_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_dl_mac_config::_internal_sfn_sf() const {
  return sfn_sf_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_dl_mac_config::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.sfn_sf)
  return _internal_sfn_sf();
}
inline void flex_dl_mac_config::_internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sfn_sf_ = value;
}
inline void flex_dl_mac_config::set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sfn_sf(value);
  // @@protoc_insertion_point(field_set:protocol.flex_dl_mac_config.sfn_sf)
}

// repeated .protocol.flex_dl_data dl_ue_data = 3;
inline int flex_dl_mac_config::_internal_dl_ue_data_size() const {
  return dl_ue_data_.size();
}
inline int flex_dl_mac_config::dl_ue_data_size() const {
  return _internal_dl_ue_data_size();
}
inline ::protocol::flex_dl_data* flex_dl_mac_config::mutable_dl_ue_data(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.dl_ue_data)
  return dl_ue_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_data >*
flex_dl_mac_config::mutable_dl_ue_data() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.dl_ue_data)
  return &dl_ue_data_;
}
inline const ::protocol::flex_dl_data& flex_dl_mac_config::_internal_dl_ue_data(int index) const {
  return dl_ue_data_.Get(index);
}
inline const ::protocol::flex_dl_data& flex_dl_mac_config::dl_ue_data(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.dl_ue_data)
  return _internal_dl_ue_data(index);
}
inline ::protocol::flex_dl_data* flex_dl_mac_config::_internal_add_dl_ue_data() {
  return dl_ue_data_.Add();
}
inline ::protocol::flex_dl_data* flex_dl_mac_config::add_dl_ue_data() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.dl_ue_data)
  return _internal_add_dl_ue_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_data >&
flex_dl_mac_config::dl_ue_data() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.dl_ue_data)
  return dl_ue_data_;
}

// repeated .protocol.flex_dl_rar dl_rar = 4;
inline int flex_dl_mac_config::_internal_dl_rar_size() const {
  return dl_rar_.size();
}
inline int flex_dl_mac_config::dl_rar_size() const {
  return _internal_dl_rar_size();
}
inline ::protocol::flex_dl_rar* flex_dl_mac_config::mutable_dl_rar(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.dl_rar)
  return dl_rar_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_rar >*
flex_dl_mac_config::mutable_dl_rar() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.dl_rar)
  return &dl_rar_;
}
inline const ::protocol::flex_dl_rar& flex_dl_mac_config::_internal_dl_rar(int index) const {
  return dl_rar_.Get(index);
}
inline const ::protocol::flex_dl_rar& flex_dl_mac_config::dl_rar(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.dl_rar)
  return _internal_dl_rar(index);
}
inline ::protocol::flex_dl_rar* flex_dl_mac_config::_internal_add_dl_rar() {
  return dl_rar_.Add();
}
inline ::protocol::flex_dl_rar* flex_dl_mac_config::add_dl_rar() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.dl_rar)
  return _internal_add_dl_rar();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_rar >&
flex_dl_mac_config::dl_rar() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.dl_rar)
  return dl_rar_;
}

// repeated .protocol.flex_dl_broadcast dl_broadcast = 5;
inline int flex_dl_mac_config::_internal_dl_broadcast_size() const {
  return dl_broadcast_.size();
}
inline int flex_dl_mac_config::dl_broadcast_size() const {
  return _internal_dl_broadcast_size();
}
inline ::protocol::flex_dl_broadcast* flex_dl_mac_config::mutable_dl_broadcast(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.dl_broadcast)
  return dl_broadcast_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_broadcast >*
flex_dl_mac_config::mutable_dl_broadcast() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.dl_broadcast)
  return &dl_broadcast_;
}
inline const ::protocol::flex_dl_broadcast& flex_dl_mac_config::_internal_dl_broadcast(int index) const {
  return dl_broadcast_.Get(index);
}
inline const ::protocol::flex_dl_broadcast& flex_dl_mac_config::dl_broadcast(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.dl_broadcast)
  return _internal_dl_broadcast(index);
}
inline ::protocol::flex_dl_broadcast* flex_dl_mac_config::_internal_add_dl_broadcast() {
  return dl_broadcast_.Add();
}
inline ::protocol::flex_dl_broadcast* flex_dl_mac_config::add_dl_broadcast() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.dl_broadcast)
  return _internal_add_dl_broadcast();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_dl_broadcast >&
flex_dl_mac_config::dl_broadcast() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.dl_broadcast)
  return dl_broadcast_;
}

// repeated .protocol.flex_pdcch_ofdm_sym_count ofdm_sym = 6;
inline int flex_dl_mac_config::_internal_ofdm_sym_size() const {
  return ofdm_sym_.size();
}
inline int flex_dl_mac_config::ofdm_sym_size() const {
  return _internal_ofdm_sym_size();
}
inline ::protocol::flex_pdcch_ofdm_sym_count* flex_dl_mac_config::mutable_ofdm_sym(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.ofdm_sym)
  return ofdm_sym_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >*
flex_dl_mac_config::mutable_ofdm_sym() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.ofdm_sym)
  return &ofdm_sym_;
}
inline const ::protocol::flex_pdcch_ofdm_sym_count& flex_dl_mac_config::_internal_ofdm_sym(int index) const {
  return ofdm_sym_.Get(index);
}
inline const ::protocol::flex_pdcch_ofdm_sym_count& flex_dl_mac_config::ofdm_sym(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.ofdm_sym)
  return _internal_ofdm_sym(index);
}
inline ::protocol::flex_pdcch_ofdm_sym_count* flex_dl_mac_config::_internal_add_ofdm_sym() {
  return ofdm_sym_.Add();
}
inline ::protocol::flex_pdcch_ofdm_sym_count* flex_dl_mac_config::add_ofdm_sym() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.ofdm_sym)
  return _internal_add_ofdm_sym();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >&
flex_dl_mac_config::ofdm_sym() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.ofdm_sym)
  return ofdm_sym_;
}

// -------------------------------------------------------------------

// flex_ul_mac_config

// optional .protocol.flex_header header = 1;
inline bool flex_ul_mac_config::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_ul_mac_config::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_ul_mac_config::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_ul_mac_config::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_mac_config.header)
  return _internal_header();
}
inline void flex_ul_mac_config::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_ul_mac_config.header)
}
inline ::protocol::flex_header* flex_ul_mac_config::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_ul_mac_config::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ul_mac_config.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_ul_mac_config::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_ul_mac_config::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ul_mac_config.header)
  return _internal_mutable_header();
}
inline void flex_ul_mac_config::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ul_mac_config.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_ul_mac_config::_internal_has_sfn_sf() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_ul_mac_config::has_sfn_sf() const {
  return _internal_has_sfn_sf();
}
inline void flex_ul_mac_config::clear_sfn_sf() {
  sfn_sf_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ul_mac_config::_internal_sfn_sf() const {
  return sfn_sf_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ul_mac_config::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_mac_config.sfn_sf)
  return _internal_sfn_sf();
}
inline void flex_ul_mac_config::_internal_set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sfn_sf_ = value;
}
inline void flex_ul_mac_config::set_sfn_sf(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sfn_sf(value);
  // @@protoc_insertion_point(field_set:protocol.flex_ul_mac_config.sfn_sf)
}

// repeated .protocol.flex_ul_data ul_ue_data = 3;
inline int flex_ul_mac_config::_internal_ul_ue_data_size() const {
  return ul_ue_data_.size();
}
inline int flex_ul_mac_config::ul_ue_data_size() const {
  return _internal_ul_ue_data_size();
}
inline ::protocol::flex_ul_data* flex_ul_mac_config::mutable_ul_ue_data(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ul_mac_config.ul_ue_data)
  return ul_ue_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_data >*
flex_ul_mac_config::mutable_ul_ue_data() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_ul_mac_config.ul_ue_data)
  return &ul_ue_data_;
}
inline const ::protocol::flex_ul_data& flex_ul_mac_config::_internal_ul_ue_data(int index) const {
  return ul_ue_data_.Get(index);
}
inline const ::protocol::flex_ul_data& flex_ul_mac_config::ul_ue_data(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_mac_config.ul_ue_data)
  return _internal_ul_ue_data(index);
}
inline ::protocol::flex_ul_data* flex_ul_mac_config::_internal_add_ul_ue_data() {
  return ul_ue_data_.Add();
}
inline ::protocol::flex_ul_data* flex_ul_mac_config::add_ul_ue_data() {
  // @@protoc_insertion_point(field_add:protocol.flex_ul_mac_config.ul_ue_data)
  return _internal_add_ul_ue_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::flex_ul_data >&
flex_ul_mac_config::ul_ue_data() const {
  // @@protoc_insertion_point(field_list:protocol.flex_ul_mac_config.ul_ue_data)
  return ul_ue_data_;
}

// -------------------------------------------------------------------

// flex_rrc_triggering

// optional .protocol.flex_header header = 1;
inline bool flex_rrc_triggering::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_rrc_triggering::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_rrc_triggering::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_rrc_triggering::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_rrc_triggering.header)
  return _internal_header();
}
inline void flex_rrc_triggering::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_rrc_triggering.header)
}
inline ::protocol::flex_header* flex_rrc_triggering::release_header() {
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_rrc_triggering::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_rrc_triggering.header)
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_rrc_triggering::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000002u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_rrc_triggering::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_rrc_triggering.header)
  return _internal_mutable_header();
}
inline void flex_rrc_triggering::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_rrc_triggering.header)
}

// optional string rrc_trigger = 2;
inline bool flex_rrc_triggering::_internal_has_rrc_trigger() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool flex_rrc_triggering::has_rrc_trigger() const {
  return _internal_has_rrc_trigger();
}
inline void flex_rrc_triggering::clear_rrc_trigger() {
  rrc_trigger_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& flex_rrc_triggering::rrc_trigger() const {
  // @@protoc_insertion_point(field_get:protocol.flex_rrc_triggering.rrc_trigger)
  return _internal_rrc_trigger();
}
inline void flex_rrc_triggering::set_rrc_trigger(const std::string& value) {
  _internal_set_rrc_trigger(value);
  // @@protoc_insertion_point(field_set:protocol.flex_rrc_triggering.rrc_trigger)
}
inline std::string* flex_rrc_triggering::mutable_rrc_trigger() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_rrc_triggering.rrc_trigger)
  return _internal_mutable_rrc_trigger();
}
inline const std::string& flex_rrc_triggering::_internal_rrc_trigger() const {
  return rrc_trigger_.Get();
}
inline void flex_rrc_triggering::_internal_set_rrc_trigger(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rrc_trigger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void flex_rrc_triggering::set_rrc_trigger(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  rrc_trigger_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_rrc_triggering.rrc_trigger)
}
inline void flex_rrc_triggering::set_rrc_trigger(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  rrc_trigger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.flex_rrc_triggering.rrc_trigger)
}
inline void flex_rrc_triggering::set_rrc_trigger(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  rrc_trigger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_rrc_triggering.rrc_trigger)
}
inline std::string* flex_rrc_triggering::_internal_mutable_rrc_trigger() {
  _has_bits_[0] |= 0x00000001u;
  return rrc_trigger_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* flex_rrc_triggering::release_rrc_trigger() {
  // @@protoc_insertion_point(field_release:protocol.flex_rrc_triggering.rrc_trigger)
  if (!_internal_has_rrc_trigger()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return rrc_trigger_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void flex_rrc_triggering::set_allocated_rrc_trigger(std::string* rrc_trigger) {
  if (rrc_trigger != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rrc_trigger_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rrc_trigger,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_rrc_triggering.rrc_trigger)
}

// optional .protocol.flex_measurement_info meas_info = 3;
inline bool flex_rrc_triggering::_internal_has_meas_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || meas_info_ != nullptr);
  return value;
}
inline bool flex_rrc_triggering::has_meas_info() const {
  return _internal_has_meas_info();
}
inline const ::protocol::flex_measurement_info& flex_rrc_triggering::_internal_meas_info() const {
  const ::protocol::flex_measurement_info* p = meas_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_measurement_info*>(
      &::protocol::_flex_measurement_info_default_instance_);
}
inline const ::protocol::flex_measurement_info& flex_rrc_triggering::meas_info() const {
  // @@protoc_insertion_point(field_get:protocol.flex_rrc_triggering.meas_info)
  return _internal_meas_info();
}
inline void flex_rrc_triggering::unsafe_arena_set_allocated_meas_info(
    ::protocol::flex_measurement_info* meas_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meas_info_);
  }
  meas_info_ = meas_info;
  if (meas_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_rrc_triggering.meas_info)
}
inline ::protocol::flex_measurement_info* flex_rrc_triggering::release_meas_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::protocol::flex_measurement_info* temp = meas_info_;
  meas_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_measurement_info* flex_rrc_triggering::unsafe_arena_release_meas_info() {
  // @@protoc_insertion_point(field_release:protocol.flex_rrc_triggering.meas_info)
  _has_bits_[0] &= ~0x00000004u;
  ::protocol::flex_measurement_info* temp = meas_info_;
  meas_info_ = nullptr;
  return temp;
}
inline ::protocol::flex_measurement_info* flex_rrc_triggering::_internal_mutable_meas_info() {
  _has_bits_[0] |= 0x00000004u;
  if (meas_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_measurement_info>(GetArena());
    meas_info_ = p;
  }
  return meas_info_;
}
inline ::protocol::flex_measurement_info* flex_rrc_triggering::mutable_meas_info() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_rrc_triggering.meas_info)
  return _internal_mutable_meas_info();
}
inline void flex_rrc_triggering::set_allocated_meas_info(::protocol::flex_measurement_info* meas_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meas_info_);
  }
  if (meas_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meas_info)->GetArena();
    if (message_arena != submessage_arena) {
      meas_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meas_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  meas_info_ = meas_info;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_rrc_triggering.meas_info)
}

// -------------------------------------------------------------------

// flex_ho_command

// optional .protocol.flex_header header = 1;
inline bool flex_ho_command::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_ho_command::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_ho_command::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_ho_command::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ho_command.header)
  return _internal_header();
}
inline void flex_ho_command::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_ho_command.header)
}
inline ::protocol::flex_header* flex_ho_command::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_ho_command::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ho_command.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_ho_command::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_ho_command::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ho_command.header)
  return _internal_mutable_header();
}
inline void flex_ho_command::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ho_command.header)
}

// optional uint32 rnti = 2;
inline bool flex_ho_command::_internal_has_rnti() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_ho_command::has_rnti() const {
  return _internal_has_rnti();
}
inline void flex_ho_command::clear_rnti() {
  rnti_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ho_command::_internal_rnti() const {
  return rnti_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ho_command::rnti() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ho_command.rnti)
  return _internal_rnti();
}
inline void flex_ho_command::_internal_set_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  rnti_ = value;
}
inline void flex_ho_command::set_rnti(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_rnti(value);
  // @@protoc_insertion_point(field_set:protocol.flex_ho_command.rnti)
}

// optional uint32 target_phy_cell_id = 3;
inline bool flex_ho_command::_internal_has_target_phy_cell_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool flex_ho_command::has_target_phy_cell_id() const {
  return _internal_has_target_phy_cell_id();
}
inline void flex_ho_command::clear_target_phy_cell_id() {
  target_phy_cell_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ho_command::_internal_target_phy_cell_id() const {
  return target_phy_cell_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ho_command::target_phy_cell_id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ho_command.target_phy_cell_id)
  return _internal_target_phy_cell_id();
}
inline void flex_ho_command::_internal_set_target_phy_cell_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  target_phy_cell_id_ = value;
}
inline void flex_ho_command::set_target_phy_cell_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_target_phy_cell_id(value);
  // @@protoc_insertion_point(field_set:protocol.flex_ho_command.target_phy_cell_id)
}

// -------------------------------------------------------------------

// flex_ue_state_change

// optional .protocol.flex_header header = 1;
inline bool flex_ue_state_change::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_ue_state_change::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_ue_state_change::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_ue_state_change::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_state_change.header)
  return _internal_header();
}
inline void flex_ue_state_change::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_ue_state_change.header)
}
inline ::protocol::flex_header* flex_ue_state_change::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_ue_state_change::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_state_change.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_ue_state_change::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_ue_state_change::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_state_change.header)
  return _internal_mutable_header();
}
inline void flex_ue_state_change::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_state_change.header)
}

// optional uint32 type = 2;
inline bool flex_ue_state_change::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool flex_ue_state_change::has_type() const {
  return _internal_has_type();
}
inline void flex_ue_state_change::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ue_state_change::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_ue_state_change::type() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_state_change.type)
  return _internal_type();
}
inline void flex_ue_state_change::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void flex_ue_state_change::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.flex_ue_state_change.type)
}

// optional .protocol.flex_ue_config config = 3;
inline bool flex_ue_state_change::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool flex_ue_state_change::has_config() const {
  return _internal_has_config();
}
inline const ::protocol::flex_ue_config& flex_ue_state_change::_internal_config() const {
  const ::protocol::flex_ue_config* p = config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_ue_config*>(
      &::protocol::_flex_ue_config_default_instance_);
}
inline const ::protocol::flex_ue_config& flex_ue_state_change::config() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_state_change.config)
  return _internal_config();
}
inline void flex_ue_state_change::unsafe_arena_set_allocated_config(
    ::protocol::flex_ue_config* config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_ue_state_change.config)
}
inline ::protocol::flex_ue_config* flex_ue_state_change::release_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_ue_config* temp = config_;
  config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_ue_config* flex_ue_state_change::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_state_change.config)
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_ue_config* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::protocol::flex_ue_config* flex_ue_state_change::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000002u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_ue_config>(GetArena());
    config_ = p;
  }
  return config_;
}
inline ::protocol::flex_ue_config* flex_ue_state_change::mutable_config() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_state_change.config)
  return _internal_mutable_config();
}
inline void flex_ue_state_change::set_allocated_config(::protocol::flex_ue_config* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config)->GetArena();
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_state_change.config)
}

// -------------------------------------------------------------------

// flex_control_delegation

// optional .protocol.flex_header header = 1;
inline bool flex_control_delegation::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_control_delegation::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_control_delegation::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_control_delegation::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.header)
  return _internal_header();
}
inline void flex_control_delegation::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_control_delegation.header)
}
inline ::protocol::flex_header* flex_control_delegation::release_header() {
  _has_bits_[0] &= ~0x00000004u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_control_delegation::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_control_delegation.header)
  _has_bits_[0] &= ~0x00000004u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_control_delegation::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000004u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_control_delegation::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_control_delegation.header)
  return _internal_mutable_header();
}
inline void flex_control_delegation::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_control_delegation.header)
}

// optional uint32 delegation_type = 2;
inline bool flex_control_delegation::_internal_has_delegation_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool flex_control_delegation::has_delegation_type() const {
  return _internal_has_delegation_type();
}
inline void flex_control_delegation::clear_delegation_type() {
  delegation_type_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_control_delegation::_internal_delegation_type() const {
  return delegation_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 flex_control_delegation::delegation_type() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.delegation_type)
  return _internal_delegation_type();
}
inline void flex_control_delegation::_internal_set_delegation_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  delegation_type_ = value;
}
inline void flex_control_delegation::set_delegation_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_delegation_type(value);
  // @@protoc_insertion_point(field_set:protocol.flex_control_delegation.delegation_type)
}

// optional bytes payload = 3;
inline bool flex_control_delegation::_internal_has_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool flex_control_delegation::has_payload() const {
  return _internal_has_payload();
}
inline void flex_control_delegation::clear_payload() {
  payload_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& flex_control_delegation::payload() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.payload)
  return _internal_payload();
}
inline void flex_control_delegation::set_payload(const std::string& value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:protocol.flex_control_delegation.payload)
}
inline std::string* flex_control_delegation::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_control_delegation.payload)
  return _internal_mutable_payload();
}
inline const std::string& flex_control_delegation::_internal_payload() const {
  return payload_.Get();
}
inline void flex_control_delegation::_internal_set_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void flex_control_delegation::set_payload(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_control_delegation.payload)
}
inline void flex_control_delegation::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.flex_control_delegation.payload)
}
inline void flex_control_delegation::set_payload(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_control_delegation.payload)
}
inline std::string* flex_control_delegation::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000001u;
  return payload_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* flex_control_delegation::release_payload() {
  // @@protoc_insertion_point(field_release:protocol.flex_control_delegation.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return payload_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void flex_control_delegation::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_control_delegation.payload)
}

// optional string name = 4;
inline bool flex_control_delegation::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool flex_control_delegation::has_name() const {
  return _internal_has_name();
}
inline void flex_control_delegation::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& flex_control_delegation::name() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.name)
  return _internal_name();
}
inline void flex_control_delegation::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:protocol.flex_control_delegation.name)
}
inline std::string* flex_control_delegation::mutable_name() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_control_delegation.name)
  return _internal_mutable_name();
}
inline const std::string& flex_control_delegation::_internal_name() const {
  return name_.Get();
}
inline void flex_control_delegation::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void flex_control_delegation::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_control_delegation.name)
}
inline void flex_control_delegation::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.flex_control_delegation.name)
}
inline void flex_control_delegation::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_control_delegation.name)
}
inline std::string* flex_control_delegation::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* flex_control_delegation::release_name() {
  // @@protoc_insertion_point(field_release:protocol.flex_control_delegation.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void flex_control_delegation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_control_delegation.name)
}

// -------------------------------------------------------------------

// flex_agent_reconfiguration

// optional .protocol.flex_header header = 1;
inline bool flex_agent_reconfiguration::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_agent_reconfiguration::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_agent_reconfiguration::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_agent_reconfiguration::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_agent_reconfiguration.header)
  return _internal_header();
}
inline void flex_agent_reconfiguration::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_agent_reconfiguration.header)
}
inline ::protocol::flex_header* flex_agent_reconfiguration::release_header() {
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_agent_reconfiguration::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_agent_reconfiguration.header)
  _has_bits_[0] &= ~0x00000002u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_agent_reconfiguration::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000002u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_agent_reconfiguration::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_agent_reconfiguration.header)
  return _internal_mutable_header();
}
inline void flex_agent_reconfiguration::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_agent_reconfiguration.header)
}

// optional string policy = 2;
inline bool flex_agent_reconfiguration::_internal_has_policy() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool flex_agent_reconfiguration::has_policy() const {
  return _internal_has_policy();
}
inline void flex_agent_reconfiguration::clear_policy() {
  policy_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& flex_agent_reconfiguration::policy() const {
  // @@protoc_insertion_point(field_get:protocol.flex_agent_reconfiguration.policy)
  return _internal_policy();
}
inline void flex_agent_reconfiguration::set_policy(const std::string& value) {
  _internal_set_policy(value);
  // @@protoc_insertion_point(field_set:protocol.flex_agent_reconfiguration.policy)
}
inline std::string* flex_agent_reconfiguration::mutable_policy() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_agent_reconfiguration.policy)
  return _internal_mutable_policy();
}
inline const std::string& flex_agent_reconfiguration::_internal_policy() const {
  return policy_.Get();
}
inline void flex_agent_reconfiguration::_internal_set_policy(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  policy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void flex_agent_reconfiguration::set_policy(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  policy_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_agent_reconfiguration.policy)
}
inline void flex_agent_reconfiguration::set_policy(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  policy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.flex_agent_reconfiguration.policy)
}
inline void flex_agent_reconfiguration::set_policy(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  policy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_agent_reconfiguration.policy)
}
inline std::string* flex_agent_reconfiguration::_internal_mutable_policy() {
  _has_bits_[0] |= 0x00000001u;
  return policy_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* flex_agent_reconfiguration::release_policy() {
  // @@protoc_insertion_point(field_release:protocol.flex_agent_reconfiguration.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return policy_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void flex_agent_reconfiguration::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  policy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policy,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_agent_reconfiguration.policy)
}

// -------------------------------------------------------------------

// flex_echo_request_latency

// -------------------------------------------------------------------

// flex_echo_reply_latency

// -------------------------------------------------------------------

// flex_disconnect

// optional .protocol.flex_header header = 1;
inline bool flex_disconnect::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool flex_disconnect::has_header() const {
  return _internal_has_header();
}
inline const ::protocol::flex_header& flex_disconnect::_internal_header() const {
  const ::protocol::flex_header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::flex_header*>(
      &::protocol::_flex_header_default_instance_);
}
inline const ::protocol::flex_header& flex_disconnect::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_disconnect.header)
  return _internal_header();
}
inline void flex_disconnect::unsafe_arena_set_allocated_header(
    ::protocol::flex_header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.flex_disconnect.header)
}
inline ::protocol::flex_header* flex_disconnect::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protocol::flex_header* flex_disconnect::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_disconnect.header)
  _has_bits_[0] &= ~0x00000001u;
  ::protocol::flex_header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::protocol::flex_header* flex_disconnect::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::flex_header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::protocol::flex_header* flex_disconnect::mutable_header() {
  // @@protoc_insertion_point(field_mutable:protocol.flex_disconnect.header)
  return _internal_mutable_header();
}
inline void flex_disconnect::set_allocated_header(::protocol::flex_header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_disconnect.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::flexran_direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flexran_direction>() {
  return ::protocol::flexran_direction_descriptor();
}
template <> struct is_proto_enum< ::protocol::flexran_err> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flexran_err>() {
  return ::protocol::flexran_err_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_bs_capability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_bs_capability>() {
  return ::protocol::flex_bs_capability_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_bs_split> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_bs_split>() {
  return ::protocol::flex_bs_split_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flexran_2eproto
